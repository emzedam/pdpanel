{
  "version": 3,
  "sources": ["../../@yaireo/tagify/dist/src/parts/constants.js", "../../@yaireo/tagify/dist/src/parts/helpers.js", "../../@yaireo/tagify/dist/src/parts/defaults.js", "../../@yaireo/tagify/dist/src/parts/dropdown.js", "../../@yaireo/tagify/dist/src/parts/events.js", "../../@yaireo/tagify/dist/src/parts/suggestions.js", "../../@yaireo/tagify/dist/src/parts/persist.js", "../../@yaireo/tagify/dist/src/parts/texts.js", "../../@yaireo/tagify/dist/src/parts/templates.js", "../../@yaireo/tagify/dist/src/tagify.js", "../../@yaireo/tagify/dist/src/parts/EventDispatcher.js"],
  "sourcesContent": ["export var ZERO_WIDTH_CHAR = '\\u200B';\nexport var ZERO_WIDTH_UNICODE_CHAR = `&#8203;`", "import {ZERO_WIDTH_CHAR} from './constants'\r\n\r\nexport const logger = {\r\n    isEnabled() { return window.TAGIFY_DEBUG ?? true},\r\n    log(...args){ this.isEnabled() && console.log('[Tagify]:', ...args) },\r\n    warn(...args) { this.isEnabled() && console.warn('[Tagify]:', ...args) }\r\n}\r\n\r\n// console.json = console.json || function(argument){\r\n//     for(var arg=0; arg < arguments.length; ++arg)\r\n//         console.log(  JSON.stringify(arguments[arg], null, 4)  )\r\n// }\r\n\r\n// const isEdge = /Edge/.test(navigator.userAgent)\r\nexport const sameStr = (s1, s2, caseSensitive, trim) => {\r\n    // cast to String\r\n    s1 = \"\"+s1;\r\n    s2 = \"\"+s2;\r\n\r\n    if( trim ){\r\n        s1 = s1.trim()\r\n        s2 = s2.trim()\r\n    }\r\n\r\n    return caseSensitive\r\n        ? s1 == s2\r\n        : s1.toLowerCase() == s2.toLowerCase()\r\n}\r\n\r\n\r\n// const getUID = () => (new Date().getTime() + Math.floor((Math.random()*10000)+1)).toString(16)\r\nexport const removeCollectionProp = (collection, unwantedProps) => collection && Array.isArray(collection) && collection.map(v => omit(v, unwantedProps))\r\n\r\nexport function omit(obj, props){\r\n    var newObj = {}, p;\r\n    for( p in obj )\r\n        if( props.indexOf(p) < 0 )\r\n            newObj[p] = obj[p]\r\n    return newObj\r\n}\r\n\r\nexport function decode( s ) {\r\n    var el = document.createElement('div');\r\n    return s.replace(/\\&#?[0-9a-z]+;/gi, function(enc){\r\n        el.innerHTML = enc;\r\n        return el.innerText\r\n    })\r\n}\r\n\r\n/**\r\n * utility method\r\n * https://stackoverflow.com/a/35385518/104380\r\n * @param  {String} s [HTML string]\r\n * @return {Object}   [DOM node]\r\n */\r\nexport function parseHTML( s ){\r\n    var parser = new DOMParser(),\r\n        node   = parser.parseFromString(s.trim(), \"text/html\");\r\n\r\n    return node.body.firstElementChild;\r\n}\r\n\r\n/**\r\n * Removed new lines and irrelevant spaces which might affect layout, and are better gone\r\n * @param {string} s [HTML string]\r\n */\r\nexport function minify( s ){\r\n    return s ? s\r\n        .replace(/\\>[\\r\\n ]+\\</g, \"><\")\r\n        .split(/>\\s+</).join('><').trim()\r\n        : \"\"\r\n}\r\n\r\nexport function removeTextChildNodes( elm ){\r\n    var iter = document.createNodeIterator(elm, NodeFilter.SHOW_TEXT, null, false),\r\n        textnode;\r\n\r\n    // print all text nodes\r\n    while (textnode = iter.nextNode()){\r\n        if( !textnode.textContent.trim() )\r\n            textnode.parentNode.removeChild(textnode)\r\n    }\r\n}\r\n\r\nexport function getfirstTextNode( elm, action ){\r\n    action = action || 'previous';\r\n    while ( elm = elm[action + 'Sibling'] )\r\n        if( elm.nodeType == 3 )\r\n            return elm\r\n}\r\n\r\n/**\r\n * utility method\r\n * https://stackoverflow.com/a/6234804/104380\r\n */\r\nexport function escapeHTML( s ){\r\n    return typeof s == 'string' ? s\r\n        .replace(/&/g, \"&amp;\")\r\n        .replace(/</g, \"&lt;\")\r\n        .replace(/>/g, \"&gt;\")\r\n        .replace(/\"/g, \"&quot;\")\r\n        .replace(/`|'/g, \"&#039;\")\r\n        : s;\r\n}\r\n\r\n/**\r\n * Checks if an argument is a javascript Object\r\n */\r\nexport function isObject(obj) {\r\n    var type = Object.prototype.toString.call(obj).split(' ')[1].slice(0, -1);\r\n    return obj === Object(obj) && type != 'Array' && type != 'Function' && type != 'RegExp' && type != 'HTMLUnknownElement';\r\n}\r\n\r\n/**\r\n * merge objects into a single new one\r\n * TEST: extend({}, {a:{foo:1}, b:[]}, {a:{bar:2}, b:[1], c:()=>{}})\r\n */\r\nexport function extend( o, o1, o2) {\r\n    if( !(o instanceof Object) ) o = {};\r\n\r\n    copy(o, o1);\r\n    if( o2 )\r\n        copy(o, o2)\r\n\r\n    function copy(a,b){\r\n        // copy o2 to o\r\n        for( var key in b )\r\n            if( b.hasOwnProperty(key) ){\r\n                if( isObject(b[key]) ){\r\n                    if( !isObject(a[key]) )\r\n                        a[key] = Object.assign({}, b[key])\r\n                    else\r\n                        copy(a[key], b[key])\r\n\r\n                    continue;\r\n                }\r\n\r\n                if( Array.isArray(b[key]) ){\r\n                    a[key] = Object.assign([], b[key])\r\n                    continue\r\n                }\r\n\r\n                a[key] = b[key]\r\n            }\r\n    }\r\n\r\n    return o\r\n}\r\n\r\n/**\r\n * concatenates N arrays without dups.\r\n * If an array's item is an Object, compare by `value`\r\n */\r\nexport function concatWithoutDups(){\r\n    const newArr = [],\r\n        existingObj = {};\r\n\r\n    for( let arr of arguments ) {\r\n        for( let item of arr ) {\r\n            // if current item is an object which has yet to be added to the new array\r\n            if( isObject(item) ){\r\n                if( !existingObj[item.value] ){\r\n                    newArr.push(item)\r\n                    existingObj[item.value] = 1\r\n                }\r\n            }\r\n\r\n            // if current item is not an object and is not in the new array\r\n            else if( !newArr.includes(item) )\r\n                newArr.push(item)\r\n        }\r\n    }\r\n\r\n    return newArr\r\n}\r\n\r\n/**\r\n *  Extracted from: https://stackoverflow.com/a/37511463/104380\r\n * @param {String} s\r\n */\r\nexport function unaccent( s ){\r\n    // if not supported, do not continue.\r\n    // developers should use a polyfill:\r\n    // https://github.com/walling/unorm\r\n    if( !String.prototype.normalize )\r\n        return s\r\n\r\n    if (typeof(s) === 'string')\r\n        return s.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\")\r\n}\r\n\r\n/**\r\n * Meassures an element's height, which might yet have been added DOM\r\n * https://stackoverflow.com/q/5944038/104380\r\n * @param {DOM} node\r\n */\r\nexport function getNodeHeight( node ){\r\n    var height, clone = node.cloneNode(true)\r\n    clone.style.cssText = \"position:fixed; top:-9999px; opacity:0\"\r\n    document.body.appendChild(clone)\r\n    height = clone.clientHeight\r\n    clone.parentNode.removeChild(clone)\r\n    return height\r\n}\r\n\r\nexport var isChromeAndroidBrowser = () => /(?=.*chrome)(?=.*android)/i.test(navigator.userAgent)\r\n\r\nexport function getUID() {\r\n    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>\r\n        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\r\n    )\r\n}\r\n\r\nexport function isNodeTag(node){\r\n    return node && node.classList && node.classList.contains(this.settings.classNames.tag)\r\n}\r\n\r\nexport function isWithinNodeTag(node){\r\n    return node && node.closest(this.settings.classNames.tagSelector)\r\n}\r\n\r\n/**\r\n* Get the caret position relative to the viewport\r\n* https://stackoverflow.com/q/58985076/104380\r\n*\r\n* @returns {object} left, top distance in pixels\r\n*/\r\nexport function getCaretGlobalPosition(){\r\n   const sel = document.getSelection()\r\n\r\n   if( sel.rangeCount ){\r\n       const r = sel.getRangeAt(0)\r\n       const node = r.startContainer\r\n       const offset = r.startOffset\r\n       let rect,  r2;\r\n\r\n       if (offset > 0) {\r\n           r2 = document.createRange()\r\n           r2.setStart(node, offset - 1)\r\n           r2.setEnd(node, offset)\r\n           rect = r2.getBoundingClientRect()\r\n           return {left:rect.right, top:rect.top, bottom:rect.bottom}\r\n       }\r\n\r\n       if( node.getBoundingClientRect )\r\n           return node.getBoundingClientRect()\r\n   }\r\n\r\n   return {left:-9999, top:-9999}\r\n}\r\n\r\n/**\r\n * Injects content (either string or node) at the current the current (or specificed) caret position\r\n * @param {content} string/node\r\n * @param {range} Object (optional, a range other than the current window selection)\r\n */\r\nexport function injectAtCaret(content, range){\r\n    var selection = window.getSelection();\r\n    range = range || selection.getRangeAt(0)\r\n\r\n    if( typeof content == 'string' )\r\n        content = document.createTextNode(content)\r\n\r\n    if( range ) {\r\n        range.deleteContents()\r\n        range.insertNode(content)\r\n    }\r\n\r\n    return content\r\n}\r\n\r\n/** Setter/Getter\r\n * Each tag DOM node contains a custom property called \"__tagifyTagData\" which hosts its data\r\n * @param {Node}   tagElm\r\n * @param {Object} data\r\n */\r\nexport function getSetTagData(tagElm, data, override){\r\n    if( !tagElm ){\r\n        logger.warn(\"tag element doesn't exist\",{tagElm, data})\r\n        return data\r\n    }\r\n\r\n    if( data )\r\n        tagElm.__tagifyTagData = override\r\n            ? data\r\n            : extend({}, tagElm.__tagifyTagData || {}, data)\r\n\r\n    return tagElm.__tagifyTagData\r\n}\r\n\r\nexport function placeCaretAfterNode( node ){\r\n    if( !node || !node.parentNode ) return\r\n\r\n    var nextSibling = node,\r\n        sel = window.getSelection(),\r\n        range = sel.getRangeAt(0);\r\n\r\n    if (sel.rangeCount) {\r\n        range.setStartAfter(nextSibling);\r\n        range.collapse(true)\r\n        // range.setEndBefore(nextSibling || node);\r\n        sel.removeAllRanges();\r\n        sel.addRange(range);\r\n    }\r\n}\r\n\r\n/**\r\n * iterate all tags, checking if multiple ones are close-siblings and if so, add a zero-space width character between them,\r\n * which forces the caret to be rendered when the selection is between tags.\r\n * Also do that if the tag is the first node.\r\n * @param {Array} tags\r\n */\r\nexport function fixCaretBetweenTags(tags, TagifyHasFocuse) {\r\n    tags.forEach(tag => {\r\n        if( getSetTagData(tag.previousSibling) || !tag.previousSibling ) {\r\n            var textNode = document.createTextNode(ZERO_WIDTH_CHAR)\r\n            tag.before(textNode)\r\n            TagifyHasFocuse && placeCaretAfterNode(textNode)\r\n        }\r\n    })\r\n}\r\n\r\n", "export default {\r\n    delimiters          : \",\",            // [RegEx] split tags by any of these delimiters (\"null\" to cancel) Example: \",| |.\"\r\n    pattern             : null,           // RegEx pattern to validate input by. Ex: /[1-9]/\r\n    tagTextProp         : 'value',        // tag data Object property which will be displayed as the tag's text\r\n    maxTags             : Infinity,       // Maximum number of tags\r\n    callbacks           : {},             // Exposed callbacks object to be triggered on certain events\r\n    addTagOnBlur        : true,           // automatically adds the text which was inputed as a tag when blur event happens\r\n    addTagOn            : ['blur', 'tab', 'enter'],  // if the tagify field (in a normal mode) has any non-tag input in it, convert it to a tag on any of these events: blur away from the field, click \"tab\"/\"enter\" key\r\n    onChangeAfterBlur   : true,           // By default, the native way of inputs' onChange events is kept, and it only fires when the field is blured.\r\n    duplicates          : false,          // \"true\" - allow duplicate tags\r\n    whitelist           : [],             // Array of tags to suggest as the user types (can be used along with \"enforceWhitelist\" setting)\r\n    blacklist           : [],             // A list of non-allowed tags\r\n    enforceWhitelist    : false,          // Only allow tags from the whitelist\r\n    userInput           : true,           // disable manually typing/pasting/editing tags (tags may only be added from the whitelist)\r\n    focusable           : true,           // Allow the component as a whole to recieve focus. There are implementations of Tagify without external border and so 'focusability' causes unwanted behaviour\r\n    keepInvalidTags     : false,          // if true, do not remove tags which did not pass validation\r\n    createInvalidTags   : true,           // if false, do not create invalid tags from invalid user input\r\n    mixTagsAllowedAfter : /,|\\.|\\:|\\s/,   // RegEx - Define conditions in which mix-tags content allows a tag to be added after\r\n    mixTagsInterpolator : ['[[', ']]'],   // Interpolation for mix mode. Everything between these will become a tag, if is a valid Object\r\n    backspace           : true,           // false / true / \"edit\"\r\n    skipInvalid         : false,          // If `true`, do not add invalid, temporary, tags before automatically removing them\r\n    pasteAsTags         : true,           // automatically converts pasted text into tags. if \"false\", allows for further text editing\r\n\r\n    editTags            : {\r\n        clicks      : 2,                  // clicks to enter \"edit-mode\": 1 for single click. any other value is considered as double-click\r\n        keepInvalid : true                // keeps invalid edits as-is until `esc` is pressed while in focus\r\n    },              // 1 or 2 clicks to edit a tag. false/null for not allowing editing\r\n    transformTag        : ()=>{},         // Takes a tag input string as argument and returns a transformed value\r\n    trim                : true,           // whether or not the value provided should be trimmed, before being added as a tag\r\n    a11y: {\r\n        focusableTags: false\r\n    },\r\n\r\n    mixMode: {\r\n        insertAfterTag  : '\\u00A0',       // String/Node to inject after a tag has been added (see #588)\r\n    },\r\n\r\n    autoComplete: {\r\n        enabled: true,        // Tries to suggest the input's value while typing (match from whitelist) by adding the rest of term as grayed-out text\r\n        rightKey: false,      // If `true`, when Right key is pressed, use the suggested value to create a tag, else just auto-completes the input. in mixed-mode this is set to \"true\"\r\n        tabKey: false,        // If 'true`, pressing `tab` key would only auto-complete but not also convert to a tag (like `rightKey` does).\r\n    },\r\n\r\n    classNames: {\r\n        namespace          : 'tagify',\r\n        mixMode            : 'tagify--mix',\r\n        selectMode         : 'tagify--select',\r\n        input              : 'tagify__input',\r\n        focus              : 'tagify--focus',\r\n        tagNoAnimation     : 'tagify--noAnim',\r\n        tagInvalid         : 'tagify--invalid',\r\n        tagNotAllowed      : 'tagify--notAllowed',\r\n        scopeLoading       : 'tagify--loading',\r\n        hasMaxTags         : 'tagify--hasMaxTags',\r\n        hasNoTags          : 'tagify--noTags',\r\n        empty              : 'tagify--empty',\r\n        inputInvalid       : 'tagify__input--invalid',\r\n        dropdown           : 'tagify__dropdown',\r\n        dropdownWrapper    : 'tagify__dropdown__wrapper',\r\n        dropdownHeader     : 'tagify__dropdown__header',\r\n        dropdownFooter     : 'tagify__dropdown__footer',\r\n        dropdownItem       : 'tagify__dropdown__item',\r\n        dropdownItemActive : 'tagify__dropdown__item--active',\r\n        dropdownItemHidden : 'tagify__dropdown__item--hidden',\r\n        dropdownInital     : 'tagify__dropdown--initial',\r\n        tag                : 'tagify__tag',\r\n        tagText            : 'tagify__tag-text',\r\n        tagX               : 'tagify__tag__removeBtn',\r\n        tagLoading         : 'tagify__tag--loading',\r\n        tagEditing         : 'tagify__tag--editable',\r\n        tagFlash           : 'tagify__tag--flash',\r\n        tagHide            : 'tagify__tag--hide',\r\n\r\n    },\r\n\r\n    dropdown: {\r\n        classname          : '',\r\n        enabled            : 2,      // minimum input characters to be typed for the suggestions dropdown to show\r\n        maxItems           : 10,\r\n        searchKeys         : [\"value\", \"searchBy\"],\r\n        fuzzySearch        : true,\r\n        caseSensitive      : false,\r\n        accentedSearch     : true,\r\n        includeSelectedTags: false,  // Should the suggestions list Include already-selected tags (after filtering)\r\n        escapeHTML         : true,   // escapes HTML entities in the suggestions' rendered text\r\n        highlightFirst     : true,   // highlights first-matched item in the list\r\n        closeOnSelect      : true,   // closes the dropdown after selecting an item, if `enabled:0` (which means always show dropdown)\r\n        clearOnSelect      : true,   // after selecting a suggetion, should the typed text input remain or be cleared\r\n        position           : 'all',  // 'manual' / 'text' / 'all'\r\n        appendTarget       : null    // defaults to document.body once DOM has been loaded\r\n    },\r\n\r\n    hooks: {\r\n        beforeRemoveTag: () => Promise.resolve(),\r\n        beforePaste: () => Promise.resolve(),\r\n        suggestionClick: () => Promise.resolve(),\r\n        beforeKeyDown: () => Promise.resolve(),\r\n    }\r\n}", "import { sameStr, isObject, minify, getNodeHeight, getCaretGlobalPosition } from './helpers'\r\nimport suggestionsMethods from './suggestions'\r\n\r\nexport function initDropdown(){\r\n    this.dropdown = {}\r\n\r\n    // auto-bind \"this\" to all the dropdown methods\r\n    for( let p in this._dropdown )\r\n        this.dropdown[p] = typeof this._dropdown[p] === 'function'\r\n            ? this._dropdown[p].bind(this)\r\n            : this._dropdown[p]\r\n\r\n    this.dropdown.refs()\r\n    this.DOM.dropdown.__tagify = this\r\n}\r\n\r\nexport default {\r\n    ...suggestionsMethods,\r\n\r\n    refs(){\r\n        this.DOM.dropdown = this.parseTemplate('dropdown', [this.settings])\r\n        this.DOM.dropdown.content = this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-wrapper']\")\r\n    },\r\n\r\n    getHeaderRef(){\r\n        return this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-header']\")\r\n    },\r\n\r\n    getFooterRef(){\r\n        return this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-footer']\")\r\n    },\r\n\r\n    getAllSuggestionsRefs(){\r\n        return [...this.DOM.dropdown.content.querySelectorAll(this.settings.classNames.dropdownItemSelector)]\r\n    },\r\n\r\n    /**\r\n     * shows the suggestions select box\r\n     * @param {String} value [optional, filter the whitelist by this value]\r\n     */\r\n    show( value ){\r\n        var _s = this.settings,\r\n            firstListItem,\r\n            firstListItemValue,\r\n            allowNewTags = _s.mode == 'mix' && !_s.enforceWhitelist,\r\n            noWhitelist =  !_s.whitelist || !_s.whitelist.length,\r\n            noMatchListItem,\r\n            isManual = _s.dropdown.position == 'manual';\r\n\r\n        // if text still exists in the input, and `show` method has no argument, then the input's text should be used\r\n        value = value === undefined ? this.state.inputText : value\r\n\r\n        // ⚠️ Do not render suggestions list  if:\r\n        // 1. there's no whitelist (can happen while async loading) AND new tags arn't allowed\r\n        // 2. dropdown is disabled\r\n        // 3. loader is showing (controlled outside of this code)\r\n        if( (noWhitelist && !allowNewTags && !_s.templates.dropdownItemNoMatch)\r\n            || _s.dropdown.enable === false\r\n            || this.state.isLoading\r\n            || this.settings.readonly )\r\n            return;\r\n\r\n        clearTimeout(this.dropdownHide__bindEventsTimeout)\r\n\r\n        // if no value was supplied, show all the \"whitelist\" items in the dropdown\r\n        // @type [Array] listItems\r\n        this.suggestedListItems = this.dropdown.filterListItems(value)\r\n\r\n        // trigger at this exact point to let the developer the chance to manually set \"this.suggestedListItems\"\r\n        if( value && !this.suggestedListItems.length ){\r\n            this.trigger('dropdown:noMatch', value)\r\n\r\n            if( _s.templates.dropdownItemNoMatch )\r\n                noMatchListItem = _s.templates.dropdownItemNoMatch.call(this, {value})\r\n        }\r\n\r\n        // if \"dropdownItemNoMatch\" was not defined, procceed regular flow.\r\n        //\r\n        if( !noMatchListItem ){\r\n            // in mix-mode, if the value isn't included in the whilelist & \"enforceWhitelist\" setting is \"false\",\r\n            // then add a custom suggestion item to the dropdown\r\n            if( this.suggestedListItems.length ){\r\n                if( value   &&   allowNewTags   &&   !this.state.editing.scope  &&  !sameStr(this.suggestedListItems[0].value, value) )\r\n                    this.suggestedListItems.unshift({value})\r\n            }\r\n            else{\r\n                if( value   &&   allowNewTags  &&  !this.state.editing.scope ){\r\n                    this.suggestedListItems = [{value}]\r\n                }\r\n                // hide suggestions list if no suggestion matched\r\n                else{\r\n                    this.input.autocomplete.suggest.call(this);\r\n                    this.dropdown.hide()\r\n                    return;\r\n                }\r\n            }\r\n\r\n            firstListItem =  this.suggestedListItems[0]\r\n            firstListItemValue = \"\"+(isObject(firstListItem) ? firstListItem.value : firstListItem)\r\n\r\n            if( _s.autoComplete && firstListItemValue ){\r\n                // only fill the sugegstion if the value of the first list item STARTS with the input value (regardless of \"fuzzysearch\" setting)\r\n                if( firstListItemValue.indexOf(value) == 0 )\r\n                    this.input.autocomplete.suggest.call(this, firstListItem)\r\n            }\r\n        }\r\n\r\n        this.dropdown.fill(noMatchListItem)\r\n\r\n        if( _s.dropdown.highlightFirst ) {\r\n            this.dropdown.highlightOption(this.DOM.dropdown.content.querySelector(_s.classNames.dropdownItemSelector))\r\n        }\r\n\r\n        // bind events, exactly at this stage of the code. \"dropdown.show\" method is allowed to be\r\n        // called multiple times, regardless if the dropdown is currently visible, but the events-binding\r\n        // should only be called if the dropdown wasn't previously visible.\r\n        if( !this.state.dropdown.visible )\r\n            // timeout is needed for when pressing arrow down to show the dropdown,\r\n            // so the key event won't get registered in the dropdown events listeners\r\n            setTimeout(this.dropdown.events.binding.bind(this))\r\n\r\n        // set the dropdown visible state to be the same as the searched value.\r\n        // MUST be set *before* position() is called\r\n        this.state.dropdown.visible = value || true\r\n        this.state.dropdown.query = value\r\n\r\n        this.setStateSelection()\r\n\r\n        // try to positioning the dropdown (it might not yet be on the page, doesn't matter, next code handles this)\r\n        if( !isManual ){\r\n            // a slight delay is needed if the dropdown \"position\" setting is \"text\", and nothing was typed in the input,\r\n            // so sadly the \"getCaretGlobalPosition\" method doesn't recognize the caret position without this delay\r\n            setTimeout(() => {\r\n                this.dropdown.position()\r\n                this.dropdown.render()\r\n            })\r\n        }\r\n\r\n        // a delay is needed because of the previous delay reason.\r\n        // this event must be fired after the dropdown was rendered & positioned\r\n        setTimeout(() => {\r\n            this.trigger(\"dropdown:show\", this.DOM.dropdown)\r\n        })\r\n    },\r\n\r\n    /**\r\n     * Hides the dropdown (if it's not managed manually by the developer)\r\n     * @param {Boolean} overrideManual\r\n     */\r\n    hide( overrideManual ){\r\n        var {scope, dropdown} = this.DOM,\r\n            isManual = this.settings.dropdown.position == 'manual' && !overrideManual;\r\n\r\n        // if there's no dropdown, this means the dropdown events aren't binded\r\n        if( !dropdown || !document.body.contains(dropdown) || isManual ) return;\r\n\r\n        window.removeEventListener('resize', this.dropdown.position)\r\n        this.dropdown.events.binding.call(this, false) // unbind all events\r\n\r\n        // if the dropdown is open, and the input (scope) is clicked,\r\n        // the dropdown should be now \"close\", and the next click (on the scope)\r\n        // should re-open it, and without a timeout, clicking to close will re-open immediately\r\n        //  clearTimeout(this.dropdownHide__bindEventsTimeout)\r\n        //  this.dropdownHide__bindEventsTimeout = setTimeout(this.events.binding.bind(this), 250)  // re-bind main events\r\n\r\n\r\n        scope.setAttribute(\"aria-expanded\", false)\r\n        dropdown.parentNode.removeChild(dropdown)\r\n\r\n        // scenario: clicking the scope to show the dropdown, clicking again to hide -> calls dropdown.hide() and then re-focuses the input\r\n        // which casues another onFocus event, which checked \"this.state.dropdown.visible\" and see it as \"false\" and re-open the dropdown\r\n        setTimeout(() => {\r\n            this.state.dropdown.visible = false\r\n        }, 100)\r\n\r\n        this.state.dropdown.query =\r\n        this.state.ddItemData =\r\n        this.state.ddItemElm =\r\n        this.state.selection = null\r\n\r\n        // if the user closed the dropdown (in mix-mode) while a potential tag was detected, flag the current tag\r\n        // so the dropdown won't be shown on following user input for that \"tag\"\r\n        if( this.state.tag && this.state.tag.value.length ){\r\n            this.state.flaggedTags[this.state.tag.baseOffset] = this.state.tag\r\n        }\r\n\r\n        this.trigger(\"dropdown:hide\", dropdown)\r\n\r\n        return this\r\n    },\r\n\r\n    /**\r\n     * Toggles dropdown show/hide\r\n     * @param {Boolean} show forces the dropdown to show\r\n     */\r\n    toggle(show){\r\n        this.dropdown[this.state.dropdown.visible && !show ? 'hide' : 'show']()\r\n    },\r\n\r\n    getAppendTarget() {\r\n        var _sd = this.settings.dropdown;\r\n        return typeof _sd.appendTarget === 'function' ? _sd.appendTarget() : _sd.appendTarget;\r\n    },\r\n\r\n    render(){\r\n        // let the element render in the DOM first, to accurately measure it.\r\n        // this.DOM.dropdown.style.cssText = \"left:-9999px; top:-9999px;\";\r\n        var ddHeight = getNodeHeight(this.DOM.dropdown),\r\n            _s = this.settings,\r\n            enabled = typeof _s.dropdown.enabled == 'number' && _s.dropdown.enabled >= 0,\r\n            appendTarget = this.dropdown.getAppendTarget();\r\n\r\n        if( !enabled ) return this;\r\n\r\n        this.DOM.scope.setAttribute(\"aria-expanded\", true)\r\n\r\n        // if the dropdown has yet to be appended to the DOM,\r\n        // append the dropdown to the body element & handle events\r\n        if( !document.body.contains(this.DOM.dropdown) ){\r\n            this.DOM.dropdown.classList.add( _s.classNames.dropdownInital )\r\n            this.dropdown.position(ddHeight)\r\n            appendTarget.appendChild(this.DOM.dropdown)\r\n\r\n            setTimeout(() =>\r\n                this.DOM.dropdown.classList.remove( _s.classNames.dropdownInital )\r\n            )\r\n        }\r\n\r\n        return this\r\n    },\r\n\r\n    /**\r\n     * re-renders the dropdown content element (see \"dropdownContent\" in templates file)\r\n     * @param {String/Array} HTMLContent - optional\r\n     */\r\n    fill( HTMLContent ){\r\n        HTMLContent = typeof HTMLContent == 'string'\r\n            ? HTMLContent\r\n            : this.dropdown.createListHTML(HTMLContent || this.suggestedListItems)\r\n\r\n        var dropdownContent = this.settings.templates.dropdownContent.call(this, HTMLContent)\r\n\r\n        this.DOM.dropdown.content.innerHTML = minify(dropdownContent)\r\n    },\r\n\r\n    /**\r\n     * Re-renders only the header & footer.\r\n     * Used when selecting a suggestion and it is wanted that the suggestions dropdown stays open.\r\n     * Since the list of sugegstions is not being re-rendered completely every time a suggestion is selected (the item is transitioned-out)\r\n     * then the header & footer should be kept in sync with the suggestions data change\r\n     */\r\n    fillHeaderFooter(){\r\n        var suggestions = this.dropdown.filterListItems(this.state.dropdown.query),\r\n            newHeaderElem = this.parseTemplate('dropdownHeader', [suggestions]),\r\n            newFooterElem = this.parseTemplate('dropdownFooter', [suggestions]),\r\n            headerRef = this.dropdown.getHeaderRef(),\r\n            footerRef = this.dropdown.getFooterRef();\r\n\r\n        newHeaderElem && headerRef?.parentNode.replaceChild(newHeaderElem, headerRef)\r\n        newFooterElem && footerRef?.parentNode.replaceChild(newFooterElem, footerRef)\r\n    },\r\n\r\n    /**\r\n     * dropdown positioning logic\r\n     * (shown above/below or next to typed text for mix-mode)\r\n     */\r\n    position( ddHeight ){\r\n        var _sd = this.settings.dropdown,\r\n            appendTarget = this.dropdown.getAppendTarget();\r\n\r\n        if( _sd.position == 'manual' || !appendTarget) return\r\n\r\n        var rect, top, bottom, left, width, ancestorsOffsets,\r\n            isPlacedAbove,\r\n            cssTop, cssLeft,\r\n            ddElm = this.DOM.dropdown,\r\n            isRTL = _sd.RTL,\r\n            isDefaultAppendTarget = appendTarget === document.body,\r\n            isSelfAppended = appendTarget === this.DOM.scope,\r\n            appendTargetScrollTop = isDefaultAppendTarget ? window.pageYOffset : appendTarget.scrollTop,\r\n            root = document.fullscreenElement || document.webkitFullscreenElement || document.documentElement,\r\n            viewportHeight = root.clientHeight,\r\n            viewportWidth = Math.max(root.clientWidth || 0, window.innerWidth || 0),\r\n            positionTo = viewportWidth > 480 ? _sd.position : 'all',\r\n            ddTarget = this.DOM[positionTo == 'input' ? 'input' : 'scope'];\r\n\r\n        ddHeight = ddHeight || ddElm.clientHeight\r\n\r\n        function getAncestorsOffsets(p){\r\n            var top = 0, left = 0;\r\n\r\n            p = p.parentNode;\r\n\r\n            // when in element-fullscreen mode, do not go above the fullscreened-element\r\n            while(p && p != root){\r\n                top += p.offsetTop || 0\r\n                left += p.offsetLeft || 0\r\n                p = p.parentNode\r\n            }\r\n\r\n            return {top, left};\r\n        }\r\n\r\n        function getAccumulatedAncestorsScrollTop() {\r\n            var scrollTop = 0,\r\n                p = _sd.appendTarget.parentNode;\r\n\r\n            while(p){\r\n                scrollTop += p.scrollTop || 0;\r\n                p = p.parentNode\r\n            }\r\n\r\n            return scrollTop;\r\n        }\r\n\r\n        if( !this.state.dropdown.visible ) return\r\n\r\n        if( positionTo == 'text' ){\r\n            rect   = getCaretGlobalPosition()\r\n            bottom = rect.bottom\r\n            top    = rect.top\r\n            left   = rect.left\r\n            width  = 'auto'\r\n        }\r\n\r\n        else{\r\n            ancestorsOffsets = getAncestorsOffsets(appendTarget)\r\n            rect   = ddTarget.getBoundingClientRect()\r\n            top    = isSelfAppended ? -1 : rect.top - ancestorsOffsets.top\r\n            bottom = (isSelfAppended ? rect.height : rect.bottom - ancestorsOffsets.top) - 1\r\n            left   = isSelfAppended ? -1 : rect.left - ancestorsOffsets.left\r\n            width  = rect.width + 'px'\r\n        }\r\n\r\n        // if the \"append target\" isn't the default, correct the `top` variable by ignoring any scrollTop of the target's Ancestors\r\n        if( !isDefaultAppendTarget ) {\r\n            let accumulatedAncestorsScrollTop = getAccumulatedAncestorsScrollTop()\r\n            top += accumulatedAncestorsScrollTop\r\n            bottom += accumulatedAncestorsScrollTop\r\n        }\r\n\r\n        top = Math.floor(top)\r\n        bottom = Math.ceil(bottom)\r\n\r\n        isPlacedAbove = _sd.placeAbove ?? viewportHeight - rect.bottom < ddHeight\r\n\r\n        // flip vertically if there is no space for the dropdown below the input\r\n        cssTop = (isPlacedAbove ? top : bottom) + appendTargetScrollTop;\r\n\r\n        // \"pageXOffset\" property is an alias for \"scrollX\"\r\n        cssLeft = `left: ${(left + (isRTL ? (rect.width || 0) : 0) + window.pageXOffset)}px;`\r\n\r\n       // rtl = rtl ?? viewportWidth -\r\n        ddElm.style.cssText = `${cssLeft}; top: ${cssTop}px; min-width: ${width}; max-width: ${width}`;\r\n\r\n        ddElm.setAttribute('placement', isPlacedAbove ? 'top' : 'bottom')\r\n        ddElm.setAttribute('position', positionTo)\r\n    },\r\n}\r\n", "import { decode, extend, getfirstTextNode, isChromeAndroidBrowser, isNodeTag, isWithinNodeTag, injectAtCaret, getSetTagData, fixCaretBetweenTags, placeCaretAfterNode } from './helpers'\r\nimport {ZERO_WIDTH_CHAR} from './constants'\r\n\r\nvar deleteBackspaceTimeout;\r\n\r\nexport function triggerChangeEvent(){\r\n    if( this.settings.mixMode.integrated ) return;\r\n\r\n    var inputElm = this.DOM.originalInput,\r\n        changed = this.state.lastOriginalValueReported !== inputElm.value,\r\n        event = new CustomEvent(\"change\", {bubbles: true}); // must use \"CustomEvent\" and not \"Event\" to support IE\r\n\r\n    if( !changed ) return;\r\n\r\n    // must apply this BEFORE triggering the simulated event\r\n    this.state.lastOriginalValueReported = inputElm.value\r\n\r\n    // React hack: https://github.com/facebook/react/issues/11488\r\n    event.simulated = true\r\n    if (inputElm._valueTracker)\r\n        inputElm._valueTracker.setValue(Math.random())\r\n\r\n    inputElm.dispatchEvent(event)\r\n\r\n    // also trigger a Tagify event\r\n    this.trigger(\"change\", this.state.lastOriginalValueReported)\r\n\r\n    // React, for some reason, clears the input's value after \"dispatchEvent\" is fired\r\n    inputElm.value = this.state.lastOriginalValueReported\r\n}\r\n\r\nexport default {\r\n    // bind custom events which were passed in the settings\r\n    customBinding(){\r\n        this.customEventsList.forEach(name => {\r\n            this.on(name, this.settings.callbacks[name])\r\n        })\r\n    },\r\n\r\n    binding( bindUnbind = true ){\r\n        var _s = this.settings,\r\n            _CB = this.events.callbacks,\r\n            _CBR,\r\n            action = bindUnbind ? 'addEventListener' : 'removeEventListener';\r\n\r\n        // do not allow the main events to be bound more than once\r\n        if( this.state.mainEvents && bindUnbind )\r\n            return;\r\n\r\n        // set the binding state of the main events, so they will not be bound more than once\r\n        this.state.mainEvents = bindUnbind;\r\n\r\n        // everything inside gets executed only once-per instance\r\n        if( bindUnbind && !this.listeners.main ){\r\n            this.events.bindGlobal.call(this);\r\n\r\n            if( this.settings.isJQueryPlugin )\r\n                jQuery(this.DOM.originalInput).on('tagify.removeAllTags', this.removeAllTags.bind(this))\r\n        }\r\n\r\n\r\n        // TODO: bind bubblable \"focusin\" and \"focusout\" events on the Tagify scope itself and not the input\r\n\r\n\r\n        // setup callback references so events could be removed later\r\n        _CBR = (this.listeners.main = this.listeners.main || {\r\n            keydown          : ['input', _CB.onKeydown.bind(this)],\r\n            click            : ['scope', _CB.onClickScope.bind(this)],\r\n            dblclick         : _s.mode != 'select' && ['scope', _CB.onDoubleClickScope.bind(this)],\r\n            paste            : ['input', _CB.onPaste.bind(this)],\r\n            drop             : ['input', _CB.onDrop.bind(this)],\r\n            compositionstart : ['input', _CB.onCompositionStart.bind(this)],\r\n            compositionend   : ['input', _CB.onCompositionEnd.bind(this)]\r\n        })\r\n\r\n        for( var eventName in _CBR ){\r\n            _CBR[eventName] && this.DOM[_CBR[eventName][0]][action](eventName, _CBR[eventName][1]);\r\n        }\r\n\r\n        // observers\r\n        var inputMutationObserver = this.listeners.main.inputMutationObserver || new MutationObserver(_CB.onInputDOMChange.bind(this));\r\n\r\n        // cleaup just-in-case\r\n        inputMutationObserver.disconnect()\r\n\r\n        // observe stuff\r\n        if( _s.mode == 'mix' ) {\r\n            inputMutationObserver.observe(this.DOM.input, {childList:true})\r\n        }\r\n\r\n        this.events.bindOriginaInputListener.call(this)\r\n    },\r\n\r\n    bindOriginaInputListener(delay) {\r\n        const DELAY = (delay||0) + 500\r\n\r\n        if(!this.listeners.main) return\r\n        // listen to original input changes (unfortunetly this is the best way...)\r\n        // https://stackoverflow.com/a/1949416/104380\r\n        clearInterval(this.listeners.main.originalInputValueObserverInterval)\r\n        this.listeners.main.originalInputValueObserverInterval = setInterval(this.events.callbacks.observeOriginalInputValue.bind(this), DELAY)\r\n    },\r\n\r\n    bindGlobal( unbind ) {\r\n        var _CB = this.events.callbacks,\r\n            action = unbind ? 'removeEventListener' : 'addEventListener',\r\n            e;\r\n\r\n        if( !this.listeners || (!unbind  && this.listeners.global) ) return; // do not re-bind\r\n\r\n        // these events are global and should never be unbinded, unless the instance is destroyed:\r\n        this.listeners.global = this.listeners.global || [\r\n            {\r\n                type: this.isIE ? 'keydown' : 'input',  // IE cannot register \"input\" events on contenteditable elements, so the \"keydown\" should be used instead..\r\n                target: this.DOM.input,\r\n                cb: _CB[this.isIE ? 'onInputIE' : 'onInput'].bind(this)\r\n            },\r\n            {\r\n                type: 'keydown',\r\n                target: window,\r\n                cb: _CB.onWindowKeyDown.bind(this)\r\n            },\r\n            {\r\n                type: 'focusin',\r\n                target: this.DOM.scope,\r\n                cb: _CB.onFocusBlur.bind(this)\r\n            },\r\n            {\r\n                type: 'focusout',\r\n                target: this.DOM.scope,\r\n                cb: _CB.onFocusBlur.bind(this)\r\n            },\r\n            {\r\n                type: 'click',\r\n                target: document,\r\n                cb: _CB.onClickAnywhere.bind(this),\r\n                useCapture: true\r\n            },\r\n        ]\r\n\r\n        for( e of this.listeners.global )\r\n            e.target[action](e.type, e.cb, !!e.useCapture);\r\n    },\r\n\r\n    unbindGlobal() {\r\n        this.events.bindGlobal.call(this, true);\r\n    },\r\n\r\n    /**\r\n     * DOM events callbacks\r\n     */\r\n    callbacks : {\r\n        onFocusBlur(e){\r\n            // when focusing within a tag which is in edit-mode\r\n            var nodeTag = isWithinNodeTag.call(this, e.target),\r\n                targetIsTagNode = isNodeTag.call(this, e.target),\r\n                isFocused = e.type == 'focusin',\r\n                lostFocus = e.type == 'focusout';\r\n\r\n            // when focusing within a tag which is in edit-mode, only and specifically on the text-part of the tag node\r\n            // and not the X button or any other custom element thatmight be there\r\n            var tagTextNode = e.target?.closest(this.settings.classNames.tagTextSelector)\r\n\r\n            if( nodeTag && isFocused && (!targetIsTagNode)) {\r\n                this.toggleFocusClass(this.state.hasFocus = +new Date())\r\n\r\n                // only if focused within a tag's text node should the `onEditTagFocus` function be called.\r\n                // if clicked anywhere else inside a tag, which had triggered an `focusin` event,\r\n                // the onFocusBlur should be aborted. This part was spcifically written for `select` mode.\r\n                // tagTextNode && this.events.callbacks.onEditTagFocus.call(this, nodeTag)\r\n            }\r\n\r\n            var _s = this.settings,\r\n                text = e.target ? this.trim(this.DOM.input.textContent) : '', // a string\r\n                currentDisplayValue = this.value?.[0]?.[_s.tagTextProp],\r\n                ddEnabled = _s.dropdown.enabled >= 0,\r\n                eventData = {relatedTarget:e.relatedTarget},\r\n                isTargetSelectOption = this.state.actions.selectOption && (ddEnabled || !_s.dropdown.closeOnSelect),\r\n                isTargetAddNewBtn = this.state.actions.addNew && ddEnabled,\r\n                shouldAddTags;\r\n\r\n            if( lostFocus ){\r\n                if( e.relatedTarget === this.DOM.scope ){\r\n                    this.dropdown.hide()\r\n                    this.DOM.input.focus()\r\n                    return\r\n                }\r\n\r\n                this.postUpdate()\r\n                // _s.onChangeAfterBlur && this.triggerChangeEvent()\r\n            }\r\n\r\n            if( isTargetSelectOption || isTargetAddNewBtn )\r\n                return;\r\n\r\n            // should only loose focus at this point if the event was not generated from within a tag, within the component\r\n            if( isFocused || nodeTag ) {\r\n                this.state.hasFocus = +new Date()\r\n                this.toggleFocusClass(this.state.hasFocus)\r\n            }\r\n            else {\r\n                this.state.hasFocus = false;\r\n            }\r\n\r\n            if( _s.mode == 'mix' ){\r\n                if( isFocused ){\r\n                    this.trigger(\"focus\", eventData)\r\n                }\r\n\r\n                else if( lostFocus ){\r\n                    this.trigger(\"blur\", eventData)\r\n                    this.loading(false)\r\n                    this.dropdown.hide()\r\n                    // reset state which needs reseting\r\n                    this.state.dropdown.visible = undefined\r\n                    this.setStateSelection()\r\n                }\r\n\r\n                return\r\n            }\r\n\r\n            if( isFocused ){\r\n                if( !_s.focusable ) return;\r\n\r\n                var dropdownCanBeShown = _s.dropdown.enabled === 0 && !this.state.dropdown.visible;\r\n\r\n                this.toggleFocusClass(true);\r\n                this.trigger(\"focus\", eventData)\r\n                //  e.target.classList.remove('placeholder');\r\n                if( dropdownCanBeShown && (!targetIsTagNode || _s.mode === 'select') ){  // && _s.mode != \"select\"\r\n                    this.dropdown.show(this.value.length ? '' : undefined)\r\n                }\r\n\r\n                return\r\n            }\r\n\r\n            else if( lostFocus ){\r\n                this.trigger(\"blur\", eventData)\r\n                this.loading(false)\r\n\r\n                // when clicking the X button of a selected tag, it is unwanted for it to be added back\r\n                // again in a few more lines of code (shouldAddTags && addTags)\r\n                if( _s.mode == 'select' ) {\r\n                    if( this.value.length ) {\r\n                        let firstTagNode = this.getTagElms()[0];\r\n                        text = this.trim(firstTagNode.textContent)\r\n                    }\r\n\r\n                    // if nothing has changed (same display value), do not add a tag\r\n                    if( currentDisplayValue === text )\r\n                        text = ''\r\n                }\r\n\r\n                shouldAddTags = text && !this.state.actions.selectOption && _s.addTagOnBlur && _s.addTagOn.includes('blur');\r\n\r\n                // do not add a tag if \"selectOption\" action was just fired (this means a tag was just added from the dropdown)\r\n                shouldAddTags && this.addTags(text, true)\r\n            }\r\n\r\n            // when clicking a tag, do not consider this is a \"blur\" event\r\n            if ( !nodeTag )  {\r\n                this.DOM.input.removeAttribute('style')\r\n                this.dropdown.hide()\r\n            }\r\n        },\r\n\r\n        onCompositionStart(e){\r\n            this.state.composing = true\r\n        },\r\n\r\n        onCompositionEnd(e){\r\n            this.state.composing = false\r\n        },\r\n\r\n        onWindowKeyDown(e){\r\n            var _s = this.settings,\r\n                focusedElm = document.activeElement,\r\n                withinTag = isWithinNodeTag.call(this, focusedElm),\r\n                isBelong = withinTag && this.DOM.scope.contains(document.activeElement),\r\n                isReadyOnlyTag = isBelong && focusedElm.hasAttribute('readonly'),\r\n                nextTag;\r\n\r\n            if( !this.state.hasFocus && (!isBelong || isReadyOnlyTag) ) return;\r\n\r\n            nextTag = focusedElm.nextElementSibling;\r\n\r\n            var targetIsRemoveBtn = e.target.classList.contains(_s.classNames.tagX);\r\n\r\n            switch( e.key ){\r\n                // remove tag if has focus\r\n                case 'Backspace': {\r\n                    if( !_s.readonly && !this.state.editing ) {\r\n                        this.removeTags(focusedElm);\r\n                        (nextTag ? nextTag : this.DOM.input).focus()\r\n                    }\r\n\r\n                    break;\r\n                }\r\n\r\n                case 'Enter': {\r\n                    if( targetIsRemoveBtn ) {\r\n                        this.removeTags( e.target.parentNode )\r\n                        return\r\n                    }\r\n\r\n                    if( _s.a11y.focusableTags && isNodeTag.call(this, focusedElm) )\r\n                        setTimeout(this.editTag.bind(this), 0, focusedElm)\r\n\r\n                    break;\r\n                }\r\n\r\n                case 'ArrowDown' : {\r\n                    // if( _s.mode == 'select' ) // issue #333\r\n                    if( !this.state.dropdown.visible && _s.mode != 'mix' )\r\n                        this.dropdown.show()\r\n                    break;\r\n                }\r\n            }\r\n        },\r\n\r\n        onKeydown(e){\r\n            var _s = this.settings;\r\n\r\n            // ignore keys during IME composition or when user input is not allowed\r\n            if( this.state.composing || !_s.userInput )\r\n                return\r\n\r\n            if( _s.mode == 'select' && _s.enforceWhitelist && this.value.length && e.key != 'Tab' ){\r\n                e.preventDefault()\r\n            }\r\n\r\n            var s = this.trim(e.target.textContent);\r\n\r\n            this.trigger(\"keydown\", {event:e})\r\n\r\n            _s.hooks.beforeKeyDown(e, {tagify:this})\r\n                .then(result => {\r\n                    /**\r\n                     * ONLY FOR MIX-MODE:\r\n                     */\r\n                    if( _s.mode == 'mix' ){\r\n                        switch( e.key ){\r\n                            case 'Left' :\r\n                            case 'ArrowLeft' : {\r\n                                // when left arrow was pressed, set a flag so when the dropdown is shown, right-arrow will be ignored\r\n                                // because it seems likely the user wishes to use the arrows to move the caret\r\n                                this.state.actions.ArrowLeft = true\r\n                                break\r\n                            }\r\n\r\n                            case 'Delete':\r\n                            case 'Backspace' : {\r\n                                if( this.state.editing ) return\r\n\r\n                                var sel = document.getSelection(),\r\n                                    deleteKeyTagDetected = e.key == 'Delete' && sel.anchorOffset == (sel.anchorNode.length || 0),\r\n                                    prevAnchorSibling = sel.anchorNode.previousSibling,\r\n                                    isCaretAfterTag = sel.anchorNode.nodeType == 1 || !sel.anchorOffset && prevAnchorSibling && prevAnchorSibling.nodeType == 1 && sel.anchorNode.previousSibling,\r\n                                    lastInputValue = decode(this.DOM.input.innerHTML),\r\n                                    lastTagElems = this.getTagElms(),\r\n                                    isZWS = sel.anchorNode.length === 1 && sel.anchorNode.nodeValue == String.fromCharCode(8203),\r\n                                    //  isCaretInsideTag = sel.anchorNode.parentNode('.' + _s.classNames.tag),\r\n                                    tagBeforeCaret,\r\n                                    tagElmToBeDeleted,\r\n                                    firstTextNodeBeforeTag;\r\n\r\n                                if( _s.backspace == 'edit' && isCaretAfterTag ){\r\n                                    tagBeforeCaret = sel.anchorNode.nodeType == 1 ? null : sel.anchorNode.previousElementSibling;\r\n                                    setTimeout(this.editTag.bind(this), 0, tagBeforeCaret); // timeout is needed to the last cahacrter in the edited tag won't get deleted\r\n                                    e.preventDefault() // needed so the tag elm won't get deleted\r\n                                    return;\r\n                                }\r\n\r\n                                if( isChromeAndroidBrowser() && isCaretAfterTag instanceof Element ){\r\n                                    firstTextNodeBeforeTag = getfirstTextNode(isCaretAfterTag)\r\n\r\n                                    if( !isCaretAfterTag.hasAttribute('readonly') )\r\n                                        isCaretAfterTag.remove() // since this is Chrome, can safetly use this \"new\" DOM API\r\n\r\n                                    // Android-Chrome wrongly hides the keyboard, and loses focus,\r\n                                    // so this hack below is needed to regain focus at the correct place:\r\n                                    this.DOM.input.focus()\r\n                                    setTimeout(() => {\r\n                                        placeCaretAfterNode(firstTextNodeBeforeTag)\r\n                                        this.DOM.input.click()\r\n\r\n                                    })\r\n\r\n                                    return\r\n                                }\r\n\r\n                                if( sel.anchorNode.nodeName == 'BR')\r\n                                    return\r\n\r\n                                if( (deleteKeyTagDetected || isCaretAfterTag) && sel.anchorNode.nodeType == 1 )\r\n                                    if( sel.anchorOffset == 0 ) // caret is at the very begining, before a tag\r\n                                        tagElmToBeDeleted = deleteKeyTagDetected // delete key pressed\r\n                                            ? lastTagElems[0]\r\n                                            : null;\r\n                                    else\r\n                                        tagElmToBeDeleted = lastTagElems[Math.min(lastTagElems.length, sel.anchorOffset) - 1]\r\n\r\n                                // find out if a tag *might* be a candidate for deletion, and if so, which\r\n                                else if( deleteKeyTagDetected )\r\n                                    tagElmToBeDeleted = sel.anchorNode.nextElementSibling;\r\n\r\n                                else if( isCaretAfterTag instanceof Element )\r\n                                    tagElmToBeDeleted = isCaretAfterTag;\r\n\r\n                                // tagElm.hasAttribute('readonly')\r\n                                if( sel.anchorNode.nodeType == 3 &&   // node at caret location is a Text node\r\n                                    !sel.anchorNode.nodeValue    &&   // has some text\r\n                                    sel.anchorNode.previousElementSibling )  // text node has a Tag node before it\r\n                                    e.preventDefault()\r\n\r\n                                // if backspace not allowed, do nothing\r\n                                // TODO: a better way to detect if nodes were deleted is to simply check the \"this.value\" before & after\r\n                                if( (isCaretAfterTag || deleteKeyTagDetected) && !_s.backspace ){\r\n                                    e.preventDefault()\r\n                                    return\r\n                                }\r\n\r\n                                if( sel.type != 'Range' && !sel.anchorOffset && sel.anchorNode == this.DOM.input && e.key != 'Delete' ){\r\n                                    e.preventDefault()\r\n                                    return\r\n                                }\r\n\r\n                                if( sel.type != 'Range' && tagElmToBeDeleted && tagElmToBeDeleted.hasAttribute('readonly') ){\r\n                                    // allows the continuation of deletion by placing the caret on the first previous textNode.\r\n                                    // since a few readonly-tags might be one after the other, iteration is needed:\r\n\r\n                                    placeCaretAfterNode( getfirstTextNode(tagElmToBeDeleted) )\r\n                                    return\r\n                                }\r\n\r\n                                if ( e.key == 'Delete' && isZWS && getSetTagData(sel.anchorNode.nextSibling) ) {\r\n                                    this.removeTags(sel.anchorNode.nextSibling)\r\n                                }\r\n\r\n                                // update regarding https://github.com/yairEO/tagify/issues/762#issuecomment-786464317:\r\n                                // the bug described is more severe than the fix below, therefore I disable the fix until a solution\r\n                                // is found which work well for both cases.\r\n                                // -------\r\n                                // nodeType is \"1\" only when the caret is at the end after last tag (no text after), or before first first (no text before)\r\n                                /*\r\n                                if( this.isFirefox && sel.anchorNode.nodeType == 1 && sel.anchorOffset != 0 ){\r\n                                    this.removeTags() // removes last tag by default if no parameter supplied\r\n                                    // place caret inside last textNode, if exist. it's an annoying bug only in FF,\r\n                                    // if the last tag is removed, and there is a textNode before it, the caret is not placed at its end\r\n                                    placeCaretAfterNode( setRangeAtStartEnd(false, this.DOM.input) )\r\n                                }\r\n                                */\r\n\r\n                                clearTimeout(deleteBackspaceTimeout)\r\n                                // a minimum delay is needed before the node actually gets detached from the document (don't know why),\r\n                                // to know exactly which tag was deleted. This is the easiest way of knowing besides using MutationObserver\r\n                                deleteBackspaceTimeout = setTimeout(() => {\r\n                                    var sel = document.getSelection(),\r\n                                        currentValue = decode(this.DOM.input.innerHTML),\r\n                                        prevElm = !deleteKeyTagDetected && sel.anchorNode.previousSibling;\r\n\r\n                                    // fixes #384, where the first and only tag will not get removed with backspace\r\n                                    /*\r\n                                    * [UPDATE DEC 3, 22] SEEMS BELOEW CODE IS NOT NEEDED ANY MORE\r\n                                    *\r\n                                    if( currentValue.length > lastInputValue.length && prevElm ){\r\n                                        if( isNodeTag.call(this, prevElm) && !prevElm.hasAttribute('readonly') ){\r\n                                            this.removeTags(prevElm)\r\n                                            this.fixFirefoxLastTagNoCaret()\r\n\r\n                                            // the above \"removeTag\" methods removes the tag with a transition. Chrome adds a <br> element for some reason at this stage\r\n                                            if( this.DOM.input.children.length == 2 && this.DOM.input.children[1].tagName == \"BR\" ){\r\n                                                this.DOM.input.innerHTML = \"\"\r\n                                                this.value.length = 0\r\n                                                return true\r\n                                            }\r\n                                        }\r\n\r\n                                        else\r\n                                            prevElm.remove()\r\n                                    }\r\n                                    */\r\n\r\n                                    // find out which tag(s) were deleted and trigger \"remove\" event\r\n                                    // iterate over the list of tags still in the document and then filter only those from the \"this.value\" collection\r\n                                    this.value = [].map.call(lastTagElems, (node, nodeIdx) => {\r\n                                        var tagData = getSetTagData(node)\r\n\r\n                                        // since readonly cannot be removed (it's technically resurrected if removed somehow)\r\n                                        if( node.parentNode || tagData.readonly )\r\n                                            return tagData\r\n                                        else\r\n                                            this.trigger('remove', { tag:node, index:nodeIdx, data:tagData })\r\n                                    })\r\n                                        .filter(n=>n)  // remove empty items in the mapped array\r\n                                }, 20) // Firefox needs this higher duration for some reason or things get buggy when deleting text from the end\r\n                                break;\r\n                            }\r\n                            // currently commented to allow new lines in mixed-mode\r\n                            // case 'Enter' :\r\n                            //     // e.preventDefault(); // solves Chrome bug - http://stackoverflow.com/a/20398191/104380\r\n                        }\r\n\r\n                        return true\r\n                    }\r\n\r\n                    var isManualDropdown = _s.dropdown.position == 'manual';\r\n\r\n                    switch( e.key ){\r\n                        case 'Backspace' :\r\n                            if( _s.mode == 'select' && _s.enforceWhitelist && this.value.length)\r\n                                this.removeTags()\r\n\r\n                            else if( !this.state.dropdown.visible || _s.dropdown.position == 'manual' ){\r\n                                if( e.target.textContent == \"\" || s.charCodeAt(0) == 8203 ){  // 8203: ZERO WIDTH SPACE unicode\r\n                                    if( _s.backspace === true )\r\n                                        this.removeTags()\r\n                                    else if( _s.backspace == 'edit' )\r\n                                        setTimeout(this.editTag.bind(this), 0) // timeout reason: when edited tag gets focused and the caret is placed at the end, the last character gets deletec (because of backspace)\r\n                                }\r\n                            }\r\n                            break;\r\n\r\n                        case 'Esc' :\r\n                        case 'Escape' :\r\n                            if( this.state.dropdown.visible ) return\r\n                            e.target.blur()\r\n                            break;\r\n\r\n                        case 'Down' :\r\n                        case 'ArrowDown' :\r\n                            // if( _s.mode == 'select' ) // issue #333\r\n                            if( !this.state.dropdown.visible )\r\n                                this.dropdown.show()\r\n                            break;\r\n\r\n                        case 'ArrowRight' : {\r\n                            let tagData = this.state.inputSuggestion || this.state.ddItemData\r\n                            if( tagData && _s.autoComplete.rightKey ){\r\n                                this.addTags([tagData], true)\r\n                                return;\r\n                            }\r\n                            break\r\n                        }\r\n                        case 'Tab' : {\r\n                            let selectMode = _s.mode == 'select'\r\n                            if(s && !selectMode) e.preventDefault()\r\n                            else return true;\r\n                        }\r\n\r\n                        case 'Enter' :\r\n                            // manual suggestion boxes are assumed to always be visible\r\n                            if( this.state.dropdown.visible && !isManualDropdown ) return\r\n                            e.preventDefault(); // solves Chrome bug - http://stackoverflow.com/a/20398191/104380\r\n                            // because the main \"keydown\" event is bound before the dropdown events, this will fire first and will not *yet*\r\n                            // know if an option was just selected from the dropdown menu. If an option was selected,\r\n                            // the dropdown events should handle adding the tag\r\n\r\n                            setTimeout(()=>{\r\n                                if( (!this.state.dropdown.visible || isManualDropdown) && !this.state.actions.selectOption && _s.addTagOn.includes(e.key.toLowerCase()) )\r\n                                    this.addTags(s, true)\r\n                            })\r\n                    }\r\n                })\r\n                .catch(err => err)\r\n        },\r\n\r\n        onInput(e){\r\n            this.postUpdate() // toggles \"tagify--empty\" class\r\n\r\n            var _s = this.settings;\r\n\r\n            if( _s.mode == 'mix' )\r\n                return this.events.callbacks.onMixTagsInput.call(this, e);\r\n\r\n            var value = this.input.normalize.call(this, undefined, {trim: false}),\r\n                showSuggestions = value.length >= _s.dropdown.enabled,\r\n                eventData = {value, inputElm:this.DOM.input},\r\n                validation = this.validateTag({value});\r\n\r\n            if( _s.mode == 'select' ) {\r\n                this.toggleScopeValidation(validation)\r\n            }\r\n\r\n            eventData.isValid = validation;\r\n\r\n            // for IE; since IE doesn't have an \"input\" event so \"keyDown\" is used instead to trigger the \"onInput\" callback,\r\n            // and so many keys do not change the input, and for those do not continue.\r\n            if( this.state.inputText == value ) return;\r\n\r\n            // save the value on the input's State object\r\n            this.input.set.call(this, value, false); // update the input with the normalized value and run validations\r\n            // this.setRangeAtStartEnd(false, this.DOM.input); // fix caret position\r\n\r\n            // if delimiters detected, add tags\r\n            if( value.search(_s.delimiters) != -1 ){\r\n                if( this.addTags( value ) ){\r\n                    this.input.set.call(this); // clear the input field's value\r\n                }\r\n            }\r\n\r\n            else if( _s.dropdown.enabled >= 0 ){\r\n                this.dropdown[showSuggestions ? \"show\" : \"hide\"](value);\r\n            }\r\n\r\n            this.trigger('input', eventData) // \"input\" event must be triggered at this point, before the dropdown is shown\r\n        },\r\n\r\n        onMixTagsInput( e ){\r\n            var rangeText, match, matchedPatternCount, tag, showSuggestions, selection,\r\n                _s = this.settings,\r\n                lastTagsCount = this.value.length,\r\n                matchFlaggedTag,\r\n                matchDelimiters,\r\n                tagsElems = this.getTagElms(),\r\n                fragment = document.createDocumentFragment(),\r\n                range = window.getSelection().getRangeAt(0),\r\n                remainingTagsValues = [].map.call(tagsElems, node => getSetTagData(node).value);\r\n\r\n            // Android Chrome \"keydown\" event argument does not report the correct \"key\".\r\n            // this workaround is needed to manually call \"onKeydown\" method with a synthesized event object\r\n            if( e.inputType == \"deleteContentBackward\" && isChromeAndroidBrowser() ){\r\n                this.events.callbacks.onKeydown.call(this, {\r\n                    target: e.target,\r\n                    key: \"Backspace\",\r\n                })\r\n            }\r\n\r\n            // if there's a tag as the first child of the input, always make sure it has a zero-width character before it\r\n            // or if two tags are next to each-other, add a zero-space width character (For the caret to appear)\r\n            fixCaretBetweenTags(this.getTagElms())\r\n\r\n            // re-add \"readonly\" tags which might have been removed\r\n            this.value.slice().forEach(item => {\r\n                if( item.readonly && !remainingTagsValues.includes(item.value) )\r\n                    fragment.appendChild( this.createTagElem(item) )\r\n            })\r\n\r\n            if( fragment.childNodes.length ){\r\n                range.insertNode(fragment)\r\n                this.setRangeAtStartEnd(false, fragment.lastChild)\r\n            }\r\n\r\n            // check if tags were \"magically\" added/removed (browser redo/undo or CTRL-A -> delete)\r\n            if( tagsElems.length != lastTagsCount ){\r\n                this.value = [].map.call(this.getTagElms(), node => getSetTagData(node))\r\n                this.update({ withoutChangeEvent:true })\r\n                return\r\n            }\r\n\r\n            if( this.hasMaxTags() )\r\n                return true\r\n\r\n            if( window.getSelection ){\r\n                selection = window.getSelection()\r\n\r\n                // only detect tags if selection is inside a textNode (not somehow on already-existing tag)\r\n                if( selection.rangeCount > 0 && selection.anchorNode.nodeType == 3 ){\r\n                    range = selection.getRangeAt(0).cloneRange()\r\n                    range.collapse(true)\r\n                    range.setStart(selection.focusNode, 0)\r\n\r\n                    rangeText = range.toString().slice(0, range.endOffset)  // slice the range so everything AFTER the caret will be trimmed\r\n                    // split = range.toString().split(_s.mixTagsAllowedAfter)  // [\"foo\", \"bar\", \"@baz\"]\r\n                    matchedPatternCount = rangeText.split(_s.pattern).length - 1;\r\n\r\n                    match = rangeText.match( _s.pattern )\r\n\r\n                    if( match )\r\n                        // tag string, example: \"@aaa ccc\"\r\n                        tag = rangeText.slice( rangeText.lastIndexOf(match[match.length-1]) )\r\n\r\n                    if( tag ){\r\n                        this.state.actions.ArrowLeft = false // start fresh, assuming the user did not (yet) used any arrow to move the caret\r\n                        this.state.tag = {\r\n                            prefix : tag.match(_s.pattern)[0],\r\n                            value  : tag.replace(_s.pattern, ''), // get rid of the prefix\r\n                        }\r\n                        this.state.tag.baseOffset = selection.baseOffset - this.state.tag.value.length\r\n\r\n                        matchDelimiters = this.state.tag.value.match(_s.delimiters)\r\n                        // if a delimeter exists, add the value as tag (exluding the delimiter)\r\n                        if( matchDelimiters ){\r\n                            this.state.tag.value = this.state.tag.value.replace(_s.delimiters, '')\r\n                            this.state.tag.delimiters = matchDelimiters[0]\r\n                            this.addTags(this.state.tag.value, _s.dropdown.clearOnSelect)\r\n                            this.dropdown.hide()\r\n                            return\r\n                        }\r\n\r\n                        showSuggestions = this.state.tag.value.length >= _s.dropdown.enabled\r\n\r\n                        // When writing something that might look like a tag (an email address) but isn't one - it is unwanted\r\n                        // the suggestions dropdown be shown, so the user can close it (in any way), and while continue typing,\r\n                        // dropdown should stay closed until another tag is typed.\r\n                        // if( this.state.tag.value.length && this.state.dropdown.visible === false )\r\n                        //     showSuggestions = false\r\n\r\n                        // test for similar flagged tags to the current tag\r\n\r\n                        try{\r\n                            matchFlaggedTag = this.state.flaggedTags[this.state.tag.baseOffset]\r\n                            matchFlaggedTag = matchFlaggedTag.prefix   == this.state.tag.prefix &&\r\n                                              matchFlaggedTag.value[0] == this.state.tag.value[0]\r\n\r\n                            // reset\r\n                            if( this.state.flaggedTags[this.state.tag.baseOffset] && !this.state.tag.value )\r\n                                delete this.state.flaggedTags[this.state.tag.baseOffset];\r\n                        }\r\n                        catch(err){}\r\n\r\n                        // scenario: (do not show suggestions of another matched tag, if more than one detected)\r\n                        // (2 tags exist)                          \" a@a.com and @\"\r\n                        // (second tag is removed by backspace)    \" a@a.com and \"\r\n                        if( matchFlaggedTag || matchedPatternCount < this.state.mixMode.matchedPatternCount )\r\n                            showSuggestions = false\r\n                    }\r\n                    // no (potential) tag found\r\n                    else{\r\n                        this.state.flaggedTags = {}\r\n                    }\r\n\r\n                    this.state.mixMode.matchedPatternCount = matchedPatternCount\r\n                }\r\n            }\r\n\r\n\r\n            // wait until the \"this.value\" has been updated (see \"onKeydown\" method for \"mix-mode\")\r\n            // the dropdown must be shown only after this event has been triggered, so an implementer could\r\n            // dynamically change the whitelist.\r\n            setTimeout(()=>{\r\n                this.update({withoutChangeEvent:true})\r\n                this.trigger('input', extend({}, this.state.tag, {textContent:this.DOM.input.textContent}))\r\n\r\n                if( this.state.tag )\r\n                    this.dropdown[showSuggestions ? \"show\" : \"hide\"](this.state.tag.value);\r\n            }, 10)\r\n        },\r\n\r\n        onInputIE(e){\r\n            var _this = this;\r\n            // for the \"e.target.textContent\" to be changed, the browser requires a small delay\r\n            setTimeout(function(){\r\n                _this.events.callbacks.onInput.call(_this, e)\r\n            })\r\n        },\r\n\r\n        observeOriginalInputValue(){\r\n            // if, for some reason, the Tagified element is no longer in the DOM,\r\n            // call the \"destroy\" method to kill all references to timeouts/intervals\r\n            if( !this.DOM.originalInput.parentNode ) this.destroy()\r\n\r\n            // if original input value changed for some reason (for exmaple a form reset)\r\n            if( this.DOM.originalInput.value != this.DOM.originalInput.tagifyValue )\r\n                this.loadOriginalValues()\r\n        },\r\n\r\n        onClickAnywhere(e){\r\n            if (e.target != this.DOM.scope && !this.DOM.scope.contains(e.target)) {\r\n                this.toggleFocusClass(false)\r\n                this.state.hasFocus = false\r\n\r\n                // do not hide the dropdown if a click was initiated within it and that dropdown belongs to this Tagify instance\r\n                if( e.target.closest('.tagify__dropdown') && e.target.closest('.tagify__dropdown').__tagify != this )\r\n                    this.dropdown.hide()\r\n            }\r\n        },\r\n\r\n        onClickScope(e){\r\n            var _s = this.settings,\r\n                tagElm = e.target.closest('.' + _s.classNames.tag),\r\n                isScope = e.target === this.DOM.scope,\r\n                timeDiffFocus = +new Date() - this.state.hasFocus;\r\n\r\n            if( isScope && _s.mode != 'select' ){\r\n                // if( !this.state.hasFocus )\r\n                    this.DOM.input.focus()\r\n                return\r\n            }\r\n\r\n            else if( e.target.classList.contains(_s.classNames.tagX) ){\r\n                this.removeTags( e.target.parentNode )\r\n                return\r\n            }\r\n\r\n            else if( tagElm && !this.state.editing ){\r\n                this.trigger(\"click\", { tag:tagElm, index:this.getNodeIndex(tagElm), data:getSetTagData(tagElm), event:e })\r\n\r\n                if( _s.editTags === 1 || _s.editTags.clicks === 1 || _s.mode == 'select' )\r\n                    this.events.callbacks.onDoubleClickScope.call(this, e)\r\n\r\n                return\r\n            }\r\n\r\n            // when clicking on the input itself\r\n            else if( e.target == this.DOM.input ){\r\n                if( _s.mode == 'mix' ){\r\n                    // firefox won't show caret if last element is a tag (and not a textNode),\r\n                    // so an empty textnode should be added\r\n                    this.fixFirefoxLastTagNoCaret()\r\n                }\r\n\r\n                if( timeDiffFocus > 500 || !_s.focusable ){\r\n                    if( this.state.dropdown.visible )\r\n                        this.dropdown.hide()\r\n                    else if( _s.dropdown.enabled === 0 && _s.mode != 'mix' )\r\n                        this.dropdown.show(this.value.length ? '' : undefined)\r\n                    return\r\n                }\r\n            }\r\n\r\n            if( _s.mode == 'select' && _s.dropdown.enabled === 0 && !this.state.dropdown.visible) {\r\n                this.events.callbacks.onDoubleClickScope.call(this, {...e, target: this.getTagElms()[0]})\r\n\r\n                !_s.userInput && this.dropdown.show()\r\n            }\r\n        },\r\n\r\n        // special proccess is needed for pasted content in order to \"clean\" it\r\n        onPaste(e){\r\n            e.preventDefault()\r\n\r\n            var tagsElems,\r\n                _s = this.settings,\r\n                selectModeWithoutInput =_s.mode == 'select' && _s.enforceWhitelist;\r\n\r\n            if( selectModeWithoutInput || !_s.userInput ){\r\n                return false;\r\n            }\r\n\r\n            var clipboardData, pastedText;\r\n\r\n            if( _s.readonly ) return\r\n\r\n            // Get pasted data via clipboard API\r\n            clipboardData = e.clipboardData || window.clipboardData\r\n            pastedText = clipboardData.getData('Text')\r\n\r\n            _s.hooks.beforePaste(e, {tagify:this, pastedText, clipboardData})\r\n                .then(result => {\r\n                    if( result === undefined )\r\n                        result = pastedText;\r\n\r\n                    if( result ){\r\n                        this.injectAtCaret(result, window.getSelection().getRangeAt(0))\r\n\r\n                        if( this.settings.mode == 'mix' ){\r\n                            this.events.callbacks.onMixTagsInput.call(this, e);\r\n                        }\r\n\r\n                        else if( this.settings.pasteAsTags ){\r\n                            tagsElems = this.addTags(this.state.inputText + result, true)\r\n                        }\r\n\r\n                        else {\r\n                            this.state.inputText = result\r\n                            this.dropdown.show(result)\r\n                        }\r\n                    }\r\n\r\n                    this.trigger('paste', {event: e, pastedText, clipboardData, tagsElems})\r\n                })\r\n                .catch(err => err)\r\n        },\r\n\r\n        onDrop(e){\r\n            e.preventDefault()\r\n        },\r\n\r\n        onEditTagInput( editableElm, e ){\r\n            var tagElm = editableElm.closest('.' + this.settings.classNames.tag),\r\n                tagElmIdx = this.getNodeIndex(tagElm),\r\n                tagData = getSetTagData(tagElm),\r\n                textValue = this.input.normalize.call(this, editableElm),\r\n                dataForChangedProp = {[this.settings.tagTextProp]: textValue, __tagId: tagData.__tagId}, // \"__tagId\" is needed so validation will skip current tag when checking for dups\r\n                isValid = this.validateTag(dataForChangedProp), // the value could have been invalid in the first-place so make sure to re-validate it (via \"addEmptyTag\" method)\r\n                hasChanged = this.editTagChangeDetected(extend(tagData, dataForChangedProp));\r\n\r\n            // if the value is same as before-editing and the tag was valid before as well, ignore the  current \"isValid\" result, which is false-positive\r\n            if( !hasChanged && editableElm.originalIsValid === true )\r\n                isValid = true\r\n\r\n            tagElm.classList.toggle(this.settings.classNames.tagInvalid, isValid !== true)\r\n            tagData.__isValid = isValid\r\n\r\n            tagElm.title = isValid === true\r\n                ? tagData.title || tagData.value\r\n                : isValid // change the tag's title to indicate why is the tag invalid (if it's so)\r\n\r\n            // show dropdown if typed text is equal or more than the \"enabled\" dropdown setting\r\n            if( textValue.length >= this.settings.dropdown.enabled ){\r\n                // this check is needed apparently because doing browser \"undo\" will fire\r\n                //  \"onEditTagInput\" but \"this.state.editing\" will be \"false\"\r\n                if( this.state.editing )\r\n                    this.state.editing.value = textValue\r\n                this.dropdown.show(textValue)\r\n            }\r\n\r\n            this.trigger(\"edit:input\", {\r\n                tag  : tagElm,\r\n                index: tagElmIdx,\r\n                data : extend({}, this.value[tagElmIdx], {newValue:textValue}),\r\n                event: e\r\n            })\r\n        },\r\n\r\n        onEditTagPaste( tagElm, e ){\r\n            // Get pasted data via clipboard API\r\n            var clipboardData = e.clipboardData || window.clipboardData,\r\n                pastedText = clipboardData.getData('Text');\r\n\r\n            e.preventDefault()\r\n\r\n            var newNode = injectAtCaret(pastedText)\r\n            this.setRangeAtStartEnd(false, newNode)\r\n        },\r\n\r\n        onEditTagClick( tagElm, e) {\r\n            this.events.callbacks.onClickScope.call(this, e)\r\n        },\r\n\r\n        onEditTagFocus( tagElm ){\r\n            this.state.editing = {\r\n                scope: tagElm,\r\n                input: tagElm.querySelector(\"[contenteditable]\")\r\n            }\r\n        },\r\n\r\n        onEditTagBlur( editableElm, e ){\r\n            // if \"relatedTarget\" is the tag then do not continue as this should not be considered a \"blur\" event\r\n            var isRelatedTargetNodeTag = isNodeTag.call(this, e.relatedTarget)\r\n\r\n            // in \"select-mode\" when editing the tag's template to include more nodes other than the editable \"span\",\r\n            // clicking those elements should not be considered a blur event\r\n            if( this.settings.mode == 'select' && isRelatedTargetNodeTag && e.relatedTarget.contains(e.target) ) {\r\n                this.dropdown.hide()\r\n                return\r\n            }\r\n\r\n            // if \"ESC\" key was pressed then the \"editing\" state should be `false` and if so, logic should not continue\r\n            // because \"ESC\" reverts the edited tag back to how it was (replace the node) before editing\r\n            if( !this.state.editing )\r\n                return;\r\n\r\n            if( !this.state.hasFocus )\r\n                this.toggleFocusClass()\r\n\r\n            // one scenario is when selecting a suggestion from the dropdown, when editing, and by selecting it\r\n            // the \"onEditTagDone\" is called directly, already replacing the tag, so the argument \"editableElm\"\r\n            // node isn't in the DOM anynmore because it has been replaced.\r\n            if( !this.DOM.scope.contains(editableElm) ) return;\r\n\r\n            var _s           = this.settings,\r\n                tagElm       = editableElm.closest('.' + _s.classNames.tag),\r\n                tagData      = getSetTagData(tagElm),\r\n                textValue    = this.input.normalize.call(this, editableElm),\r\n                dataForChangedProp = {[_s.tagTextProp]: textValue, __tagId: tagData.__tagId}, // \"__tagId\" is needed so validation will skip current tag when checking for dups\r\n                originalData = tagData.__originalData, // pre-edit data\r\n                hasChanged   = this.editTagChangeDetected(extend(tagData, dataForChangedProp)),\r\n                isValid      = this.validateTag(dataForChangedProp), // \"__tagId\" is needed so validation will skip current tag when checking for dups\r\n                hasMaxTags,\r\n                newTagData;\r\n\r\n            if( !textValue ){\r\n                this.onEditTagDone(tagElm)\r\n                return\r\n            }\r\n\r\n            // if nothing changed revert back to how it was before editing\r\n            if( !hasChanged ){\r\n                this.onEditTagDone(tagElm, originalData)\r\n                return\r\n            }\r\n\r\n            // need to know this because if \"keepInvalidTags\" setting is \"true\" and an invalid tag is edited as a valid one,\r\n            // but the maximum number of tags have alreay been reached, so it should not allow saving the new valid value.\r\n            // only if the tag was already valid before editing, ignore this check (see a few lines below)\r\n            hasMaxTags = this.hasMaxTags()\r\n\r\n            newTagData = extend(\r\n                {},\r\n                originalData,\r\n                {\r\n                    [_s.tagTextProp]: this.trim(textValue),\r\n                    __isValid: isValid\r\n                }\r\n            )\r\n\r\n            // pass through optional transformer defined in settings\r\n            _s.transformTag.call(this, newTagData, originalData)\r\n\r\n            // MUST re-validate after tag transformation\r\n            // only validate the \"tagTextProp\" because is the only thing that metters for validating an edited tag.\r\n            // -- Scenarios: --\r\n            // 1. max 3 tags allowd. there are 4 tags, one has invalid input and is edited to a valid one, and now should be marked as \"not allowed\" because limit of tags has reached\r\n            // 2. max 3 tags allowed. there are 3 tags, one is edited, and so max-tags vaildation should be OK\r\n            isValid = (!hasMaxTags || originalData.__isValid === true) && this.validateTag(newTagData)\r\n\r\n            if( isValid !== true ){\r\n                this.trigger(\"invalid\", { data:newTagData, tag:tagElm, message:isValid })\r\n\r\n                // do nothing if invalid, stay in edit-mode until corrected or reverted by presssing esc\r\n                if( _s.editTags.keepInvalid ) return\r\n\r\n                if( _s.keepInvalidTags )\r\n                    newTagData.__isValid = isValid\r\n                else\r\n                    // revert back if not specified to keep\r\n                    newTagData = originalData\r\n            }\r\n\r\n            else if( _s.keepInvalidTags ){\r\n                // cleaup any previous leftovers if the tag was invalid\r\n                delete newTagData.title\r\n                delete newTagData[\"aria-invalid\"]\r\n                delete newTagData.class\r\n            }\r\n\r\n            // tagElm.classList.toggle(_s.classNames.tagInvalid, true)\r\n\r\n            this.onEditTagDone(tagElm, newTagData)\r\n        },\r\n\r\n        onEditTagkeydown(e, tagElm){\r\n            // ignore keys during IME composition\r\n            if( this.state.composing )\r\n                return\r\n\r\n            this.trigger(\"edit:keydown\", {event:e})\r\n\r\n            switch( e.key ){\r\n                case 'Esc' :\r\n                case 'Escape' : {\r\n                    this.state.editing = false\r\n                    var hasValueToRevertTo = !!tagElm.__tagifyTagData.__originalData.value\r\n\r\n                    if( hasValueToRevertTo )\r\n                        // revert the tag to how it was before editing\r\n                        // replace current tag with original one (pre-edited one)\r\n                        tagElm.parentNode.replaceChild(tagElm.__tagifyTagData.__originalHTML, tagElm)\r\n                    else\r\n                        tagElm.remove()\r\n\r\n                    break\r\n                }\r\n                case 'Enter' :\r\n                case 'Tab' : {\r\n                    e.preventDefault()\r\n\r\n                    var EDITED_TAG_BLUR_DELAY = 0;\r\n\r\n                    // a setTimeout is used so when editing (in \"select\" mode) while the dropdown is shown and a suggestion is highlighted\r\n                    // and ENTER key is pressed down - the `dropdown.hide` method won't be invoked immediately and unbind the dropdown's\r\n                    // KEYDOWN \"ENTER\" before it has time to call the handler and select the suggestion.\r\n                    setTimeout(() => e.target.blur(), EDITED_TAG_BLUR_DELAY)\r\n                }\r\n            }\r\n        },\r\n\r\n        onDoubleClickScope(e){\r\n            var tagElm = e.target.closest('.' + this.settings.classNames.tag),\r\n                tagData = getSetTagData(tagElm),\r\n                _s = this.settings,\r\n                isEditingTag,\r\n                isReadyOnlyTag;\r\n\r\n            if( !tagElm || tagData.editable === false ) return\r\n\r\n            isEditingTag = tagElm.classList.contains(this.settings.classNames.tagEditing)\r\n            isReadyOnlyTag = tagElm.hasAttribute('readonly')\r\n\r\n            if( !_s.readonly && !isEditingTag && !isReadyOnlyTag && this.settings.editTags && _s.userInput ) {\r\n                this.events.callbacks.onEditTagFocus.call(this, tagElm)\r\n                this.editTag(tagElm)\r\n            }\r\n\r\n            this.toggleFocusClass(true)\r\n\r\n            if( _s.mode != 'select' )\r\n                this.trigger('dblclick', { tag:tagElm, index:this.getNodeIndex(tagElm), data:getSetTagData(tagElm) })\r\n        },\r\n\r\n        /**\r\n         *\r\n         * @param {Object} m an object representing the observed DOM changes\r\n         */\r\n        onInputDOMChange(m){\r\n            // iterate all DOM mutation\r\n            m.forEach(record => {\r\n                // only the ADDED nodes\r\n                record.addedNodes.forEach(addedNode => {\r\n                    // fix chrome's placing '<div><br></div>' everytime ENTER key is pressed, and replace with just `<br'\r\n                    if( addedNode.outerHTML == '<div><br></div>' ){\r\n                        addedNode.replaceWith(document.createElement('br'))\r\n                    }\r\n\r\n                    // if the added element is a div containing a tag within it (chrome does this when pressing ENTER before a tag)\r\n                    else if( addedNode.nodeType == 1 && addedNode.querySelector(this.settings.classNames.tagSelector) ){\r\n                        let newlineText = document.createTextNode('')\r\n\r\n                        if( addedNode.childNodes[0].nodeType == 3 && addedNode.previousSibling.nodeName != 'BR' )\r\n                            newlineText  = document.createTextNode('\\n')\r\n\r\n                        // unwrap the useless div\r\n                        // chrome adds a BR at the end which should be removed\r\n                        addedNode.replaceWith(...[newlineText, ...[...addedNode.childNodes].slice(0,-1)])\r\n                        placeCaretAfterNode(newlineText)\r\n                    }\r\n\r\n                    // if this is a tag\r\n                    else if( isNodeTag.call(this, addedNode) ){\r\n                        if( addedNode.previousSibling?.nodeType == 3 && !addedNode.previousSibling.textContent )\r\n                            addedNode.previousSibling.remove()\r\n\r\n                        // and it is the first node in a new line\r\n                        if( addedNode.previousSibling && addedNode.previousSibling.nodeName == 'BR' ){\r\n                            // allows placing the caret just before the tag, when the tag is the first node in that line\r\n                            addedNode.previousSibling.replaceWith('\\n' + ZERO_WIDTH_CHAR)\r\n\r\n                            let nextNode = addedNode.nextSibling, anythingAfterNode = '';\r\n\r\n                            while (nextNode) {\r\n                                anythingAfterNode += nextNode.textContent\r\n                                nextNode = nextNode.nextSibling;\r\n                            }\r\n\r\n                            // when hitting ENTER for new line just before an existing tag, but skip below logic when a tag has been addded\r\n                            anythingAfterNode.trim() && placeCaretAfterNode(addedNode.previousSibling)\r\n                        }\r\n\r\n                        // if previous sibling does not exists (meanning the addedNode is the first node in this.DOM.input)\r\n                        // or, if the previous sibling is also a tag, add a zero-space character before (to allow showing the caret in Chrome)\r\n                        else if( !addedNode.previousSibling || getSetTagData(addedNode.previousSibling) ){\r\n                            addedNode.before(ZERO_WIDTH_CHAR)\r\n                        }\r\n                    }\r\n                })\r\n\r\n                record.removedNodes.forEach(removedNode => {\r\n                    // when trying to delete a tag which is in a new line and there's nothing else there (caret is after the tag)\r\n                    if( removedNode && removedNode.nodeName == 'BR' && isNodeTag.call(this, lastInputChild)){\r\n                        this.removeTags(lastInputChild)\r\n                        this.fixFirefoxLastTagNoCaret()\r\n                    }\r\n                })\r\n            })\r\n\r\n            // get the last child only after the above DOM modifications\r\n            // check these scenarios:\r\n            // 1. after a single line, press ENTER once - should add only 1 BR\r\n            // 2. presss ENTER right before a tag\r\n            // 3. press enter within a text node before a tag\r\n            var lastInputChild = this.DOM.input.lastChild;\r\n\r\n            if( lastInputChild && lastInputChild.nodeValue == '' )\r\n                lastInputChild.remove()\r\n\r\n            // make sure the last element is always a BR\r\n            if( !lastInputChild || lastInputChild.nodeName != 'BR' ){\r\n                this.DOM.input.appendChild(document.createElement('br'))\r\n            }\r\n        },\r\n    }\r\n}\r\n\r\n", "import { isObject, escapeHTML, extend, unaccent, logger } from './helpers'\n\n\n/**\n * Tagify's dropdown suggestions-related logic\n */\n\nexport default {\n    events : {\n        /**\n         * Events should only be binded when the dropdown is rendered and removed when isn't\n         * because there might be multiple Tagify instances on a certain page\n         * @param  {Boolean} bindUnbind [optional. true when wanting to unbind all the events]\n         */\n        binding( bindUnbind = true ){\n            // references to the \".bind()\" methods must be saved so they could be unbinded later\n            var _CB = this.dropdown.events.callbacks,\n                // callback-refs\n                _CBR = (this.listeners.dropdown = this.listeners.dropdown || {\n                    position          : this.dropdown.position.bind(this, null),\n                    onKeyDown         : _CB.onKeyDown.bind(this),\n                    onMouseOver       : _CB.onMouseOver.bind(this),\n                    onMouseLeave      : _CB.onMouseLeave.bind(this),\n                    onClick           : _CB.onClick.bind(this),\n                    onScroll          : _CB.onScroll.bind(this),\n                }),\n                action = bindUnbind ? 'addEventListener' : 'removeEventListener';\n\n            if( this.settings.dropdown.position != 'manual' ){\n                document[action]('scroll', _CBR.position, true)\n                window[action]('resize', _CBR.position)\n                window[action]('keydown', _CBR.onKeyDown)\n            }\n\n            this.DOM.dropdown[action]('mouseover', _CBR.onMouseOver)\n            this.DOM.dropdown[action]('mouseleave', _CBR.onMouseLeave)\n            this.DOM.dropdown[action]('mousedown', _CBR.onClick)\n            this.DOM.dropdown.content[action]('scroll', _CBR.onScroll)\n        },\n\n        callbacks : {\n            onKeyDown(e){\n                // ignore keys during IME composition\n                if( !this.state.hasFocus || this.state.composing )\n                    return\n\n                // get the \"active\" element, and if there was none (yet) active, use first child\n                var _s = this.settings,\n                    selectedElm = this.DOM.dropdown.querySelector(_s.classNames.dropdownItemActiveSelector),\n                    selectedElmData = this.dropdown.getSuggestionDataByNode(selectedElm),\n                    isMixMode = _s.mode == 'mix',\n                    isSelectMode = _s.mode == 'select';\n\n                _s.hooks.beforeKeyDown(e, {tagify:this})\n                    .then(result => {\n                        switch( e.key ){\n                            case 'ArrowDown' :\n                            case 'ArrowUp' :\n                            case 'Down' :  // >IE11\n                            case 'Up' : {  // >IE11\n                                e.preventDefault()\n                                var dropdownItems = this.dropdown.getAllSuggestionsRefs(),\n                                    actionUp = e.key == 'ArrowUp' || e.key == 'Up';\n\n                                if( selectedElm ) {\n                                    selectedElm = this.dropdown.getNextOrPrevOption(selectedElm, !actionUp)\n                                }\n\n                                // if no element was found OR current item is not a \"real\" item, loop\n                                if( !selectedElm || !selectedElm.matches(_s.classNames.dropdownItemSelector) ){\n                                    selectedElm = dropdownItems[actionUp ? dropdownItems.length - 1 : 0];\n                                }\n\n                                this.dropdown.highlightOption(selectedElm, true)\n                                // selectedElm.scrollIntoView({inline: 'nearest', behavior: 'smooth'})\n                                break;\n                            }\n                            case 'Escape' :\n                            case 'Esc': // IE11\n                                this.dropdown.hide();\n                                break;\n\n                            case 'ArrowRight' :\n                                if( this.state.actions.ArrowLeft )\n                                    return\n                            case 'Tab' : {\n                                let shouldAutocompleteOnKey = !_s.autoComplete.rightKey || !_s.autoComplete.tabKey\n\n                                // in mix-mode, treat arrowRight like Enter key, so a tag will be created\n                                if( !isMixMode && !isSelectMode && selectedElm && shouldAutocompleteOnKey && !this.state.editing ){\n                                    e.preventDefault() // prevents blur so the autocomplete suggestion will not become a tag\n                                    var value = this.dropdown.getMappedValue(selectedElmData)\n\n                                    this.input.autocomplete.set.call(this, value)\n                                    return false\n                                }\n                                return true\n                            }\n                            case 'Enter' : {\n                                e.preventDefault()\n\n                                _s.hooks.suggestionClick(e, {tagify:this, tagData:selectedElmData, suggestionElm:selectedElm})\n                                    .then(() => {\n                                        if( selectedElm ){\n                                            this.dropdown.selectOption(selectedElm)\n                                            // highlight next option\n                                            selectedElm = this.dropdown.getNextOrPrevOption(selectedElm, !actionUp)\n                                            this.dropdown.highlightOption(selectedElm)\n                                            return\n                                        }\n                                        else\n                                            this.dropdown.hide()\n\n                                        if( !isMixMode )\n                                            this.addTags(this.state.inputText.trim(), true)\n                                    })\n                                    .catch(err => logger.warn(err))\n\n                                break;\n                            }\n                            case 'Backspace' : {\n                                if( isMixMode || this.state.editing.scope ) return;\n\n                                const value = this.input.raw.call(this)\n\n                                if( value == \"\" || value.charCodeAt(0) == 8203 ){\n                                    if( _s.backspace === true )\n                                        this.removeTags()\n                                    else if( _s.backspace == 'edit' )\n                                        setTimeout(this.editTag.bind(this), 0)\n                                }\n                            }\n                        }\n                    })\n            },\n\n            onMouseOver(e){\n                var ddItem = e.target.closest(this.settings.classNames.dropdownItemSelector)\n                // event delegation check\n                this.dropdown.highlightOption(ddItem)\n            },\n\n            onMouseLeave(e){\n                // de-highlight any previously highlighted option\n                this.dropdown.highlightOption()\n            },\n\n            onClick(e){\n                if( e.button != 0 || e.target == this.DOM.dropdown || e.target == this.DOM.dropdown.content ) return; // allow only mouse left-clicks\n\n                var selectedElm = e.target.closest(this.settings.classNames.dropdownItemSelector),\n                    selectedElmData = this.dropdown.getSuggestionDataByNode(selectedElm)\n\n                // temporary set the \"actions\" state to indicate to the main \"blur\" event it shouldn't run\n                this.state.actions.selectOption = true;\n                setTimeout(()=> this.state.actions.selectOption = false, 50)\n\n                this.settings.hooks.suggestionClick(e, {tagify:this, tagData:selectedElmData, suggestionElm:selectedElm})\n                    .then(() => {\n                        if( selectedElm )\n                            this.dropdown.selectOption(selectedElm, e)\n                        else\n                            this.dropdown.hide()\n                    })\n                    .catch(err => logger.warn(err))\n            },\n\n            onScroll(e){\n                var elm = e.target,\n                    pos = elm.scrollTop / (elm.scrollHeight - elm.parentNode.clientHeight) * 100;\n\n                this.trigger(\"dropdown:scroll\", {percentage:Math.round(pos)})\n            },\n        }\n    },\n\n    /**\n     * fill data into the suggestions list\n     * (mainly used to update the list when removing tags while the suggestions dropdown is visible, so they will be re-added to the list. not efficient)\n     */\n    refilter( value ){\n        value = value || this.state.dropdown.query || ''\n        this.suggestedListItems = this.dropdown.filterListItems(value)\n\n        this.dropdown.fill()\n\n        if( !this.suggestedListItems.length )\n            this.dropdown.hide()\n\n        this.trigger(\"dropdown:updated\", this.DOM.dropdown)\n    },\n\n    /**\n     * Given a suggestion-item, return the data associated with it\n     * @param {HTMLElement} tagElm\n     * @returns Object\n     */\n    getSuggestionDataByNode( tagElm ){\n        var value = tagElm && tagElm.getAttribute('value')\n        return this.suggestedListItems.find(item => item.value == value) || null\n    },\n\n    getNextOrPrevOption(selected, next = true) {\n        var dropdownItems = this.dropdown.getAllSuggestionsRefs(),\n            selectedIdx = dropdownItems.findIndex(item => item === selected);\n\n        return next ? dropdownItems[selectedIdx + 1] : dropdownItems[selectedIdx - 1]\n    },\n\n    /**\n     * mark the currently active suggestion option\n     * @param {Object}  elm            option DOM node\n     * @param {Boolean} adjustScroll   when navigation with keyboard arrows (up/down), aut-scroll to always show the highlighted element\n     */\n    highlightOption( elm, adjustScroll ){\n        var className = this.settings.classNames.dropdownItemActive,\n            itemData;\n\n        // focus casues a bug in Firefox with the placeholder been shown on the input element\n        // if( this.settings.dropdown.position != 'manual' )\n        //     elm.focus();\n\n        if( this.state.ddItemElm ){\n            this.state.ddItemElm.classList.remove(className)\n            this.state.ddItemElm.removeAttribute(\"aria-selected\")\n        }\n\n        if( !elm ){\n            this.state.ddItemData = null\n            this.state.ddItemElm = null\n            this.input.autocomplete.suggest.call(this)\n            return;\n        }\n\n        itemData = this.dropdown.getSuggestionDataByNode(elm)\n        this.state.ddItemData = itemData\n        this.state.ddItemElm = elm\n\n        // this.DOM.dropdown.querySelectorAll(\".\" + this.settings.classNames.dropdownItemActive).forEach(activeElm => activeElm.classList.remove(className));\n        elm.classList.add(className);\n        elm.setAttribute(\"aria-selected\", true)\n\n        if( adjustScroll )\n            elm.parentNode.scrollTop = elm.clientHeight + elm.offsetTop - elm.parentNode.clientHeight\n\n        // Try to autocomplete the typed value with the currently highlighted dropdown item\n        if( this.settings.autoComplete ){\n            this.input.autocomplete.suggest.call(this, itemData)\n            this.dropdown.position() // suggestions might alter the height of the tagify wrapper because of unkown suggested term length that could drop to the next line\n        }\n    },\n\n    /**\n     * Create a tag from the currently active suggestion option\n     * @param {Object} elm  DOM node to select\n     * @param {Object} event The original Click event, if available (since keyboard ENTER key also triggers this method)\n     */\n    selectOption( elm, event ){\n        var _s = this.settings,\n            {clearOnSelect, closeOnSelect} = _s.dropdown;\n\n        if( !elm ) {\n            this.addTags(this.state.inputText, true)\n            closeOnSelect && this.dropdown.hide()\n            return;\n        }\n\n        event = event || {}\n\n        // if in edit-mode, do not continue but instead replace the tag's text.\n        // the scenario is that \"addTags\" was called from a dropdown suggested option selected while editing\n\n        var value = elm.getAttribute('value'),\n            isNoMatch = value == 'noMatch',\n            isMixMode = _s.mode == 'mix',\n            tagData = this.suggestedListItems.find(item => (item.value ?? item) == value)\n\n        // The below event must be triggered, regardless of anything else which might go wrong\n        this.trigger('dropdown:select', {data:tagData, elm, event})\n\n        if( !value || !tagData && !isNoMatch ){\n            closeOnSelect && setTimeout(this.dropdown.hide.bind(this))\n            return\n        }\n\n        if( this.state.editing ) {\n            let normalizedTagData = this.normalizeTags([tagData])[0]\n            tagData =  _s.transformTag.call(this, normalizedTagData) || normalizedTagData\n\n            // normalizing value, because \"tagData\" might be a string, and therefore will not be able to extend the object\n            this.onEditTagDone(null, extend({__isValid: true}, tagData))\n        }\n        // Tagify instances should re-focus to the input element once an option was selected, to allow continuous typing\n        else {\n            this[isMixMode ? \"addMixTags\" : \"addTags\"]([tagData || this.input.raw.call(this)], clearOnSelect)\n        }\n\n        if( !isMixMode && !this.DOM.input.parentNode )\n            return\n\n        setTimeout(() => {\n            this.DOM.input.focus()\n            this.toggleFocusClass(true)\n        })\n\n        closeOnSelect && setTimeout(this.dropdown.hide.bind(this))\n\n        // execute these tasks once a suggestion has been selected\n        elm.addEventListener('transitionend', () => {\n            this.dropdown.fillHeaderFooter()\n            setTimeout(() => {\n                elm.remove()\n                this.dropdown.refilter()\n            }, 100)\n        }, {once: true})\n\n        // hide selected suggestion\n        elm.classList.add(this.settings.classNames.dropdownItemHidden)\n    },\n\n    // adds all the suggested items, including the ones which are not currently rendered,\n    // unless specified otherwise (by the \"onlyRendered\" argument)\n    selectAll( onlyRendered ){\n        // having suggestedListItems with items messes with \"normalizeTags\" when wanting\n        // to add all tags\n        this.suggestedListItems.length = 0;\n        this.dropdown.hide()\n\n        this.dropdown.filterListItems('');\n\n        var tagsToAdd = this.dropdown.filterListItems('');\n\n        if( !onlyRendered )\n            tagsToAdd = this.state.dropdown.suggestions\n\n        // some whitelist items might have already been added as tags so when addings all of them,\n        // skip adding already-added ones, so best to use \"filterListItems\" method over \"settings.whitelist\"\n        this.addTags(tagsToAdd, true)\n        return this\n    },\n\n    /**\n     * returns an HTML string of the suggestions' list items\n     * @param {String} value string to filter the whitelist by\n     * @param {Object} options \"exact\" - for exact complete match\n     * @return {Array} list of filtered whitelist items according to the settings provided and current value\n     */\n    filterListItems( value, options ){\n        var _s = this.settings,\n            _sd = _s.dropdown,\n            options = options || {},\n            list = [],\n            exactMatchesList = [],\n            whitelist = _s.whitelist,\n            suggestionsCount = _sd.maxItems >= 0 ? _sd.maxItems : Infinity,\n            searchKeys = _sd.searchKeys,\n            whitelistItem,\n            valueIsInWhitelist,\n            searchBy,\n            isDuplicate,\n            niddle,\n            i = 0;\n\n        value = (_s.mode == 'select' && this.value.length && this.value[0][_s.tagTextProp] == value\n            ? '' // do not filter if the tag, which is already selecetd in \"select\" mode, is the same as the typed text\n            : value);\n\n        if( !value || !searchKeys.length ){\n            list = _sd.includeSelectedTags\n                ? whitelist\n                : whitelist.filter(item => !this.isTagDuplicate( isObject(item) ? item.value : item )) // don't include tags which have already been added.\n\n            this.state.dropdown.suggestions = list;\n            return list.slice(0, suggestionsCount); // respect \"maxItems\" dropdown setting\n        }\n\n        niddle = _sd.caseSensitive\n            ? \"\"+value\n            : (\"\"+value).toLowerCase()\n\n        // checks if ALL of the words in the search query exists in the current whitelist item, regardless of their order\n        function stringHasAll(s, query){\n            return query.toLowerCase().split(' ').every(q => s.includes(q.toLowerCase()))\n        }\n\n        for( ; i < whitelist.length; i++ ){\n            let startsWithMatch, exactMatch;\n\n            whitelistItem = whitelist[i] instanceof Object ? whitelist[i] : { value:whitelist[i] } //normalize value as an Object\n\n            let itemWithoutSearchKeys = !Object.keys(whitelistItem).some(k => searchKeys.includes(k) ),\n                _searchKeys = itemWithoutSearchKeys ? [\"value\"] : searchKeys\n\n            if( _sd.fuzzySearch && !options.exact ){\n                searchBy = _searchKeys.reduce((values, k) => values + \" \" + (whitelistItem[k]||\"\"), \"\").toLowerCase().trim()\n\n                if( _sd.accentedSearch ){\n                    searchBy = unaccent(searchBy)\n                    niddle = unaccent(niddle)\n                }\n\n                startsWithMatch = searchBy.indexOf(niddle) == 0\n                exactMatch = searchBy === niddle\n                valueIsInWhitelist = stringHasAll(searchBy, niddle)\n            }\n\n            else {\n                startsWithMatch = true;\n                valueIsInWhitelist = _searchKeys.some(k => {\n                    var v = '' + (whitelistItem[k] || '') // if key exists, cast to type String\n\n                    if( _sd.accentedSearch ){\n                        v = unaccent(v)\n                        niddle = unaccent(niddle)\n                    }\n\n                    if( !_sd.caseSensitive )\n                        v = v.toLowerCase()\n\n                    exactMatch = v === niddle\n\n                    return options.exact\n                        ? v === niddle\n                        : v.indexOf(niddle) == 0\n                })\n            }\n\n            isDuplicate = !_sd.includeSelectedTags && this.isTagDuplicate( isObject(whitelistItem) ? whitelistItem.value : whitelistItem )\n\n            // match for the value within each \"whitelist\" item\n            if( valueIsInWhitelist && !isDuplicate )\n                if( exactMatch && startsWithMatch)\n                    exactMatchesList.push(whitelistItem)\n                else if( _sd.sortby == 'startsWith' && startsWithMatch )\n                    list.unshift(whitelistItem)\n                else\n                    list.push(whitelistItem)\n        }\n\n        this.state.dropdown.suggestions = exactMatchesList.concat(list);\n\n        // custom sorting function\n        return typeof _sd.sortby == 'function'\n            ? _sd.sortby(exactMatchesList.concat(list), niddle)\n            : exactMatchesList.concat(list).slice(0, suggestionsCount)\n    },\n\n    /**\n     * Returns the final value of a tag data (object) with regards to the \"mapValueTo\" dropdown setting\n     * @param {Object} tagData\n     * @returns\n     */\n    getMappedValue(tagData){\n        var mapValueTo = this.settings.dropdown.mapValueTo,\n            value = (mapValueTo\n                ? typeof mapValueTo == 'function' ? mapValueTo(tagData) : (tagData[mapValueTo] || tagData.value)\n                : tagData.value);\n\n        return value\n    },\n\n    /**\n     * Creates the dropdown items' HTML\n     * @param  {Array} sugegstionsList  [Array of Objects]\n     * @return {String}\n     */\n    createListHTML( sugegstionsList ){\n        return extend([], sugegstionsList).map((suggestion, idx) => {\n            if( typeof suggestion == 'string' || typeof suggestion == 'number' )\n                suggestion = {value:suggestion}\n\n            var mappedValue = this.dropdown.getMappedValue(suggestion);\n\n            mappedValue = (typeof mappedValue == 'string' && this.settings.dropdown.escapeHTML)\n                ? escapeHTML(mappedValue)\n                : mappedValue;\n\n            return this.settings.templates.dropdownItem.apply(this, [{...suggestion, mappedValue}, this])\n        }).join(\"\")\n    }\n}", "const VERSION = 1; // current version of persisted data. if code change breaks persisted data, verison number should be bumped.\r\nconst STORE_KEY = '@yaireo/tagify/'\r\n\r\nexport const getPersistedData = id => key => {\r\n    // if \"persist\" is \"false\", do not save to localstorage\r\n    let customKey = '/'+key,\r\n        persistedData,\r\n        versionMatch = localStorage.getItem(STORE_KEY + id + '/v', VERSION) == VERSION\r\n\r\n    if( versionMatch ){\r\n        try{ persistedData = JSON.parse(localStorage[STORE_KEY + id + customKey]) }\r\n        catch(err){}\r\n    }\r\n\r\n    return persistedData\r\n}\r\n\r\nexport const setPersistedData = id => {\r\n    if( !id ) return () => {};\r\n\r\n    // for storage invalidation\r\n    localStorage.setItem(STORE_KEY + id + '/v', VERSION)\r\n\r\n    return (data, key) => {\r\n        let customKey = '/'+key,\r\n            persistedData = JSON.stringify(data)\r\n\r\n        if( data && key ){\r\n            localStorage.setItem(STORE_KEY + id + customKey, persistedData)\r\n            dispatchEvent( new Event('storage') )\r\n        }\r\n    }\r\n}\r\n\r\nexport const clearPersistedData = id => key => {\r\n    const base = STORE_KEY + '/' + id + '/';\r\n\r\n    // delete specific key in the storage\r\n    if( key )\r\n        localStorage.removeItem(base + key)\r\n\r\n    // delete all keys in the storage with a specific tagify id\r\n    else {\r\n        for(let k in localStorage)\r\n            if( k.includes(base) )\r\n                localStorage.removeItem(k)\r\n    }\r\n}\r\n", "export default {\r\n    empty      : \"empty\",\r\n    exceed     : \"number of tags exceeded\",\r\n    pattern    : \"pattern mismatch\",\r\n    duplicate  : \"already exists\",\r\n    notAllowed : \"not allowed\"\r\n}", "import {ZERO_WIDTH_UNICODE_CHAR} from './constants'\r\n\r\nexport default {\r\n    /**\r\n     *\r\n     * @param {DOM Object} input     Original input DOm element\r\n     * @param {Object}     settings  Tagify instance settings Object\r\n     */\r\n    wrapper(input, _s){\r\n        return `<tags class=\"${_s.classNames.namespace} ${_s.mode ? `${_s.classNames[_s.mode + \"Mode\"]}` : \"\"} ${input.className}\"\r\n                    ${_s.readonly ? 'readonly' : ''}\r\n                    ${_s.disabled ? 'disabled' : ''}\r\n                    ${_s.required ? 'required' : ''}\r\n                    ${_s.mode === 'select' ? \"spellcheck='false'\" : ''}\r\n                    tabIndex=\"-1\">\r\n                    ${this.settings.templates.input.call(this)}\r\n                ${ZERO_WIDTH_UNICODE_CHAR}\r\n        </tags>`\r\n    },\r\n\r\n    input() {\r\n        var _s = this.settings,\r\n            placeholder = _s.placeholder || ZERO_WIDTH_UNICODE_CHAR;\r\n\r\n        return `<span ${!_s.readonly && _s.userInput ? 'contenteditable' : ''} tabIndex=\"0\" data-placeholder=\"${placeholder}\" aria-placeholder=\"${_s.placeholder || ''}\"\r\n                    class=\"${_s.classNames.input}\"\r\n                    role=\"textbox\"\r\n                    aria-autocomplete=\"both\"\r\n                    aria-multiline=\"${_s.mode=='mix'?true:false}\"></span>`\r\n    },\r\n\r\n    tag(tagData, {settings: _s}){\r\n        return `<tag title=\"${(tagData.title || tagData.value)}\"\r\n                    contenteditable='false'\r\n                    spellcheck='false'\r\n                    tabIndex=\"${_s.a11y.focusableTags ? 0 : -1}\"\r\n                    class=\"${_s.classNames.tag} ${tagData.class || \"\"}\"\r\n                    ${this.getAttributes(tagData)}>\r\n            <x title='' tabIndex=\"${_s.a11y.focusableTags ? 0 : -1}\" class=\"${_s.classNames.tagX}\" role='button' aria-label='remove tag'></x>\r\n            <div>\r\n                <span ${_s.mode === 'select' && _s.userInput ? \"contenteditable='true'\" : ''} class=\"${_s.classNames.tagText}\">${tagData[_s.tagTextProp] || tagData.value}</span>\r\n            </div>\r\n        </tag>`\r\n    },\r\n\r\n    dropdown(settings){\r\n        var _sd = settings.dropdown,\r\n            isManual = _sd.position == 'manual';\r\n\r\n        return `<div class=\"${isManual ? '' : settings.classNames.dropdown } ${_sd.classname}\" role=\"listbox\" aria-labelledby=\"dropdown\" dir=\"${_sd.RTL ? 'rtl' : ''}\">\r\n                    <div data-selector='tagify-suggestions-wrapper' class=\"${settings.classNames.dropdownWrapper}\"></div>\r\n                </div>`\r\n    },\r\n\r\n    dropdownContent(HTMLContent) {\r\n        var _t = this.settings.templates,\r\n            suggestions = this.state.dropdown.suggestions;\r\n\r\n        return `\r\n            ${_t.dropdownHeader.call(this, suggestions)}\r\n            ${HTMLContent}\r\n            ${_t.dropdownFooter.call(this, suggestions)}\r\n        `\r\n    },\r\n\r\n    dropdownItem(item){\r\n        return `<div ${this.getAttributes(item)}\r\n                    class='${this.settings.classNames.dropdownItem} ${item.class || \"\"}'\r\n                    tabindex=\"0\"\r\n                    role=\"option\">${item.mappedValue || item.value}</div>`\r\n    },\r\n\r\n    /**\r\n     * @param {Array} suggestions An array of all the matched suggested items, including those which were sliced away due to the \"dropdown.maxItems\" setting\r\n     */\r\n    dropdownHeader(suggestions){\r\n        return `<header data-selector='tagify-suggestions-header' class=\"${this.settings.classNames.dropdownHeader}\"></header>`\r\n    },\r\n\r\n    dropdownFooter(suggestions){\r\n        var hasMore = suggestions.length - this.settings.dropdown.maxItems;\r\n\r\n        return hasMore > 0\r\n            ? `<footer data-selector='tagify-suggestions-footer' class=\"${this.settings.classNames.dropdownFooter}\">\r\n                ${hasMore} more items. Refine your search.\r\n            </footer>`\r\n            : '';\r\n    },\r\n\r\n    dropdownItemNoMatch: null\r\n}\r\n", "import { sameStr, removeCollectionProp, omit, isObject, parseHTML, removeTextChildNodes, escapeHTML, extend, concatWithoutDups, getUID, isNodeTag, injectAtCaret, placeCaretAfterNode, getSetTagData, fixCaretBetweenTags, logger } from './parts/helpers'\r\nimport DEFAULTS from './parts/defaults'\r\nimport _dropdown, { initDropdown } from './parts/dropdown'\r\nimport { getPersistedData, setPersistedData, clearPersistedData } from './parts/persist'\r\nimport TEXTS from './parts/texts'\r\nimport templates from './parts/templates'\r\nimport EventDispatcher from './parts/EventDispatcher'\r\nimport events, { triggerChangeEvent } from './parts/events'\r\n\r\n/**\r\n * @constructor\r\n * @param {Object} input    DOM element\r\n * @param {Object} settings settings object\r\n */\r\nfunction Tagify( input, settings ){\r\n    if( !input ){\r\n        logger.warn('input element not found', input)\r\n        // return an empty mock of all methods, so the code using tagify will not break\r\n        // because it might be calling methods even though the input element does not exist\r\n        const mockInstance = new Proxy(this, { get(){ return () => mockInstance } })\r\n        return mockInstance\r\n    }\r\n\r\n    if( input.__tagify ){\r\n        logger.warn('input element is already Tagified - Same instance is returned.', input)\r\n        return input.__tagify\r\n    }\r\n\r\n    extend(this, EventDispatcher(this))\r\n    this.isFirefox = (/firefox|fxios/i).test(navigator.userAgent) && !(/seamonkey/i).test(navigator.userAgent)\r\n    this.isIE = window.document.documentMode; // https://developer.mozilla.org/en-US/docs/Web/API/Document/compatMode#Browser_compatibility\r\n\r\n    settings = settings || {};\r\n    this.getPersistedData = getPersistedData(settings.id)\r\n    this.setPersistedData = setPersistedData(settings.id)\r\n    this.clearPersistedData = clearPersistedData(settings.id)\r\n    this.applySettings(input, settings)\r\n\r\n    this.state = {\r\n        inputText: '',\r\n        editing : false,\r\n        composing: false,\r\n        actions : {},   // UI actions for state-locking\r\n        mixMode : {},\r\n        dropdown: {},\r\n        flaggedTags: {} // in mix-mode, when a string is detetced as potential tag, and the user has chocen to close the suggestions dropdown, keep the record of the tasg here\r\n    }\r\n\r\n    this.value = [] // tags' data\r\n\r\n    // events' callbacks references will be stores here, so events could be unbinded\r\n    this.listeners = {}\r\n\r\n    this.DOM = {} // Store all relevant DOM elements in an Object\r\n\r\n    this.build(input)\r\n    initDropdown.call(this)\r\n\r\n    this.getCSSVars()\r\n    this.loadOriginalValues()\r\n\r\n    this.events.customBinding.call(this)\r\n    this.events.binding.call(this)\r\n    input.autofocus && this.DOM.input.focus()\r\n    input.__tagify = this\r\n}\r\n\r\nTagify.prototype = {\r\n    _dropdown,\r\n    placeCaretAfterNode,\r\n    getSetTagData,\r\n    helpers: {sameStr, removeCollectionProp, omit, isObject, parseHTML, escapeHTML, extend, concatWithoutDups, getUID, isNodeTag},\r\n\r\n    customEventsList : ['change', 'add', 'remove', 'invalid', 'input', 'paste', 'click', 'keydown', 'focus', 'blur', 'edit:input', 'edit:beforeUpdate', 'edit:updated', 'edit:start', 'edit:keydown', 'dropdown:show', 'dropdown:hide', 'dropdown:select', 'dropdown:updated', 'dropdown:noMatch', 'dropdown:scroll'],\r\n    dataProps: ['__isValid', '__removed', '__originalData', '__originalHTML', '__tagId'], // internal-uasge props\r\n\r\n    trim(text){\r\n        return this.settings.trim && text && typeof text == \"string\" ? text.trim() : text\r\n    },\r\n\r\n    // expose this handy utility function\r\n    parseHTML,\r\n\r\n    templates,\r\n\r\n    parseTemplate(template, data){\r\n        template = this.settings.templates[template] || template;\r\n        return parseHTML( template.apply(this, data) )\r\n    },\r\n\r\n    set whitelist( arr ){\r\n        const isArray = arr && Array.isArray(arr)\r\n        this.settings.whitelist = isArray ? arr : []\r\n        this.setPersistedData(isArray ? arr : [], 'whitelist')\r\n    },\r\n\r\n    get whitelist(){\r\n        return this.settings.whitelist\r\n    },\r\n\r\n    set userInput( state ){\r\n        this.settings.userInput = !!state\r\n        this.setContentEditable(!!state)\r\n    },\r\n\r\n    get userInput(){\r\n        return this.settings.userInput\r\n    },\r\n\r\n    generateClassSelectors(classNames){\r\n        for( let name in classNames ) {\r\n            let currentName = name;\r\n            Object.defineProperty(classNames, currentName + \"Selector\" , {\r\n                get(){ return \".\" + this[currentName].split(\" \")[0] }\r\n            })\r\n        }\r\n    },\r\n\r\n    applySettings( input, settings ){\r\n        DEFAULTS.templates = this.templates\r\n\r\n        var mixModeDefaults = {\r\n            dropdown: {\r\n                position: \"text\"\r\n            }\r\n        }\r\n\r\n        var mergedDefaults = extend({}, DEFAULTS, (settings.mode == 'mix' ? mixModeDefaults : {}));\r\n        var _s = this.settings = extend({}, mergedDefaults, settings)\r\n\r\n        _s.disabled = input.hasAttribute('disabled')\r\n        _s.readonly = _s.readonly || input.hasAttribute('readonly')\r\n        _s.placeholder = escapeHTML(input.getAttribute('placeholder') || _s.placeholder || \"\")\r\n        _s.required = input.hasAttribute('required')\r\n\r\n        this.generateClassSelectors(_s.classNames)\r\n\r\n        if ( _s.dropdown.includeSelectedTags === undefined )\r\n            _s.dropdown.includeSelectedTags = _s.duplicates;\r\n\r\n        if( this.isIE )\r\n            _s.autoComplete = false; // IE goes crazy if this isn't false\r\n\r\n        [\"whitelist\", \"blacklist\"].forEach(name => {\r\n            var attrVal = input.getAttribute('data-' + name)\r\n            if( attrVal ){\r\n                attrVal = attrVal.split(_s.delimiters)\r\n                if( attrVal instanceof Array )\r\n                    _s[name] = attrVal\r\n            }\r\n        })\r\n\r\n        // backward-compatibility for old version of \"autoComplete\" setting:\r\n        if( \"autoComplete\" in settings && !isObject(settings.autoComplete) ){\r\n            _s.autoComplete = DEFAULTS.autoComplete\r\n            _s.autoComplete.enabled = settings.autoComplete\r\n        }\r\n\r\n        if( _s.mode == 'mix' ){\r\n            _s.pattern = _s.pattern || /@/;\r\n            _s.autoComplete.rightKey = true\r\n            _s.delimiters = settings.delimiters || null // default dlimiters in mix-mode must be NULL\r\n\r\n            // needed for \"filterListItems\". This assumes the user might have forgotten to manually\r\n            // define the same term in \"dropdown.searchKeys\" as defined in \"tagTextProp\" setting, so\r\n            // by automatically adding it, tagify is \"helping\" out, guessing the intesntions of the developer.\r\n            if( _s.tagTextProp && !_s.dropdown.searchKeys.includes(_s.tagTextProp) )\r\n                _s.dropdown.searchKeys.push(_s.tagTextProp)\r\n        }\r\n\r\n        if( input.pattern )\r\n            try { _s.pattern = new RegExp(input.pattern)  }\r\n            catch(e){}\r\n\r\n        // Convert the \"delimiters\" setting into a REGEX object\r\n        if( _s.delimiters ){\r\n            _s._delimiters = _s.delimiters;\r\n            try { _s.delimiters = new RegExp(this.settings.delimiters, \"g\") }\r\n            catch(e){}\r\n        }\r\n\r\n        if( _s.disabled )\r\n            _s.userInput = false;\r\n\r\n        this.TEXTS = {...TEXTS, ...(_s.texts || {})}\r\n\r\n        // make sure the dropdown will be shown on \"focus\" and not only after typing something (in \"select\" mode)\r\n        if( (_s.mode == 'select' && !settings.dropdown?.enabled) || !_s.userInput ){\r\n            _s.dropdown.enabled = 0\r\n        }\r\n\r\n        _s.dropdown.appendTarget = settings.dropdown?.appendTarget || document.body;\r\n\r\n\r\n        // get & merge persisted data with current data\r\n        let persistedWhitelist = this.getPersistedData('whitelist');\r\n\r\n        if( Array.isArray(persistedWhitelist))\r\n            this.whitelist = Array.isArray(_s.whitelist)\r\n                ? concatWithoutDups(_s.whitelist, persistedWhitelist)\r\n                : persistedWhitelist;\r\n    },\r\n\r\n    /**\r\n     * Returns a string of HTML element attributes\r\n     * @param {Object} data [Tag data]\r\n     */\r\n    getAttributes( data ){\r\n        var attrs = this.getCustomAttributes(data), s = '', k;\r\n\r\n        for( k in attrs )\r\n            s += \" \" + k + (data[k] !== undefined ? `=\"${attrs[k]}\"` : \"\");\r\n\r\n        return s;\r\n    },\r\n\r\n    /**\r\n     * Returns an object of attributes to be used for the templates\r\n     */\r\n    getCustomAttributes( data ){\r\n        // only items which are objects have properties which can be used as attributes\r\n        if( !isObject(data) )\r\n            return '';\r\n\r\n        var output = {}, propName;\r\n\r\n        for( propName in data ){\r\n            if( propName.slice(0,2) != '__' && propName != 'class' && data.hasOwnProperty(propName) && data[propName] !== undefined )\r\n                output[propName] = escapeHTML(data[propName])\r\n        }\r\n        return output\r\n    },\r\n\r\n    setStateSelection(){\r\n        var selection = window.getSelection()\r\n\r\n        // save last selection place to be able to inject anything from outside to that specific place\r\n        var sel = {\r\n            anchorOffset: selection.anchorOffset,\r\n            anchorNode  : selection.anchorNode,\r\n            range       : selection.getRangeAt && selection.rangeCount && selection.getRangeAt(0)\r\n        }\r\n\r\n        this.state.selection = sel\r\n        return sel\r\n    },\r\n\r\n    /**\r\n     * Get specific CSS variables which are relevant to this script and parse them as needed.\r\n     * The result is saved on the instance in \"this.CSSVars\"\r\n     */\r\n    getCSSVars(){\r\n        var compStyle = getComputedStyle(this.DOM.scope, null)\r\n\r\n        const getProp = name => compStyle.getPropertyValue('--'+name)\r\n\r\n        function seprateUnitFromValue(a){\r\n            if( !a ) return {}\r\n            a = a.trim().split(' ')[0]\r\n            var unit  = a.split(/\\d+/g).filter(n=>n).pop().trim(),\r\n                value = +a.split(unit).filter(n=>n)[0].trim()\r\n            return {value, unit}\r\n        }\r\n\r\n        this.CSSVars = {\r\n            tagHideTransition: (({value, unit}) => unit=='s' ? value * 1000 : value)(seprateUnitFromValue(getProp('tag-hide-transition')))\r\n        }\r\n    },\r\n\r\n    /**\r\n     * builds the HTML of this component\r\n     * @param  {Object} input [DOM element which would be \"transformed\" into \"Tags\"]\r\n     */\r\n    build( input ){\r\n        var DOM  = this.DOM,\r\n            labelWrapper = input.closest('label');\r\n\r\n        if( this.settings.mixMode.integrated ){\r\n            DOM.originalInput = null;\r\n            DOM.scope = input;\r\n            DOM.input = input;\r\n        }\r\n\r\n        else {\r\n            DOM.originalInput = input\r\n            DOM.originalInput_tabIndex = input.tabIndex\r\n            DOM.scope = this.parseTemplate('wrapper', [input, this.settings])\r\n            DOM.input = DOM.scope.querySelector(this.settings.classNames.inputSelector)\r\n            input.parentNode.insertBefore(DOM.scope, input)\r\n            input.tabIndex = -1; // do not allow focus or typing directly, once tagified\r\n        }\r\n\r\n        // fixes tagify nested inside a <label> tag from getting focus when clicked on\r\n        if( labelWrapper )\r\n            labelWrapper.setAttribute('for', '')\r\n    },\r\n\r\n    /**\r\n     * revert any changes made by this component\r\n     */\r\n    destroy(){\r\n        this.events.unbindGlobal.call(this)\r\n        this.DOM.scope.parentNode.removeChild(this.DOM.scope)\r\n        this.DOM.originalInput.tabIndex = this.DOM.originalInput_tabIndex\r\n        delete this.DOM.originalInput.__tagify\r\n        this.dropdown.hide(true)\r\n        this.removeAllCustomListeners()\r\n        clearTimeout(this.dropdownHide__bindEventsTimeout)\r\n        clearInterval(this.listeners.main.originalInputValueObserverInterval)\r\n    },\r\n\r\n    /**\r\n     * if the original input has any values, add them as tags\r\n     */\r\n    loadOriginalValues( value ){\r\n        var lastChild,\r\n            _s = this.settings\r\n\r\n        // temporarily block firing the \"change\" event on the original input until\r\n        // this method finish removing current value and adding a new one\r\n        this.state.blockChangeEvent = true\r\n\r\n        if( value === undefined ){\r\n            const persistedOriginalValue = this.getPersistedData('value')\r\n\r\n            // if the field already has a field, trust its the desired\r\n            // one to be rendered and do not use the persisted one\r\n            if( persistedOriginalValue && !this.DOM.originalInput.value )\r\n                value = persistedOriginalValue\r\n            else\r\n                value = _s.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value\r\n        }\r\n\r\n        this.removeAllTags()\r\n\r\n        if( value ){\r\n            if( _s.mode == 'mix' ){\r\n                this.parseMixTags(value)\r\n\r\n                lastChild = this.DOM.input.lastChild\r\n\r\n                // fixes a Chrome bug, when the last node in `mix-mode` is a tag, the caret appears at the far-top-top, outside the field\r\n                if( !lastChild || lastChild.tagName != 'BR' )\r\n                    this.DOM.input.insertAdjacentHTML('beforeend', '<br>')\r\n            }\r\n\r\n            else{\r\n                try{\r\n                    if( JSON.parse(value) instanceof Array )\r\n                        value = JSON.parse(value)\r\n                }\r\n                catch(err){}\r\n                this.addTags(value, true).forEach(tag => tag && tag.classList.add(_s.classNames.tagNoAnimation))\r\n            }\r\n        }\r\n\r\n        else\r\n            this.postUpdate()\r\n\r\n        this.state.lastOriginalValueReported = _s.mixMode.integrated ? '' : this.DOM.originalInput.value\r\n    },\r\n\r\n    cloneEvent(e){\r\n        var clonedEvent = {}\r\n        for( var v in e )\r\n            if( v != 'path' )\r\n                clonedEvent[v] = e[v]\r\n        return clonedEvent\r\n    },\r\n\r\n    /**\r\n     * Toogle global loading state on/off\r\n     * Useful when fetching async whitelist while user is typing\r\n     * @param {Boolean} isLoading\r\n     */\r\n    loading( isLoading ){\r\n        this.state.isLoading = isLoading\r\n        // IE11 doesn't support toggle with second parameter\r\n        this.DOM.scope.classList[isLoading ? \"add\" : \"remove\"](this.settings.classNames.scopeLoading)\r\n        return this\r\n    },\r\n\r\n    /**\r\n     * Toogle a tag loading state on/off\r\n     * @param {Boolean} isLoading\r\n     */\r\n    tagLoading( tagElm, isLoading ){\r\n        if( tagElm )\r\n            // IE11 doesn't support toggle with second parameter\r\n            tagElm.classList[isLoading ? \"add\" : \"remove\"](this.settings.classNames.tagLoading)\r\n        return this\r\n    },\r\n\r\n    /**\r\n     * Toggles class on the main tagify container (\"scope\")\r\n     * @param {String} className\r\n     * @param {Boolean} force\r\n     */\r\n    toggleClass( className, force ){\r\n        if( typeof className == 'string' )\r\n            this.DOM.scope.classList.toggle(className, force)\r\n    },\r\n\r\n    toggleScopeValidation( validation ){\r\n        var isValid = validation === true || validation === undefined; // initially it is undefined\r\n\r\n        if( !this.settings.required && validation && validation === this.TEXTS.empty)\r\n            isValid = true\r\n\r\n        this.toggleClass(this.settings.classNames.tagInvalid, !isValid)\r\n        this.DOM.scope.title = isValid ? '' : validation\r\n    },\r\n\r\n    toggleFocusClass( force ){\r\n        this.toggleClass(this.settings.classNames.focus, !!force)\r\n    },\r\n\r\n    /**\r\n     * Sets the templates placeholder after initialization\r\n     * @param {String} str\r\n     */\r\n    setPlaceholder(str) {\r\n        ['data', 'aria'].forEach(p => this.DOM.input.setAttribute(`${p}-placeholder`, str))\r\n    },\r\n\r\n    triggerChangeEvent,\r\n\r\n    events,\r\n\r\n    fixFirefoxLastTagNoCaret(){\r\n        return // seems to be fixed in newer version of FF, so retiring below code (for now)\r\n        // var inputElm = this.DOM.input\r\n\r\n        // if( this.isFirefox && inputElm.childNodes.length && inputElm.lastChild.nodeType == 1 ){\r\n        //     inputElm.appendChild(document.createTextNode(\"\\u200b\"))\r\n        //     this.setRangeAtStartEnd(true, inputElm)\r\n        //     return true\r\n        // }\r\n    },\r\n\r\n    /** https://stackoverflow.com/a/59156872/104380\r\n     * @param {Boolean} start indicating where to place it (start or end of the node)\r\n     * @param {Object}  node  DOM node to place the caret at\r\n     */\r\n    setRangeAtStartEnd( start, node ){\r\n        if( !node ) return;\r\n\r\n        start = typeof start == 'number' ? start : !!start\r\n        node = node.lastChild || node;\r\n        var sel = document.getSelection()\r\n\r\n        // do not force caret placement if the current selection (focus) is on another element (not this tagify instance)\r\n        if( sel.focusNode instanceof Element && !this.DOM.input.contains(sel.focusNode) ) {\r\n            return true\r\n        }\r\n\r\n        try{\r\n            if( sel.rangeCount >= 1 ){\r\n                ['Start', 'End'].forEach(pos =>\r\n                    sel.getRangeAt(0)[\"set\" + pos](node, start ? start : node.length)\r\n                )\r\n            }\r\n        } catch(err){\r\n            console.warn(err)\r\n        }\r\n    },\r\n\r\n    insertAfterTag( tagElm, newNode ){\r\n        newNode = newNode || this.settings.mixMode.insertAfterTag;\r\n\r\n        if( !tagElm || !tagElm.parentNode || !newNode ) return\r\n\r\n        newNode = typeof newNode == 'string'\r\n            ? document.createTextNode(newNode)\r\n            : newNode\r\n\r\n        tagElm.parentNode.insertBefore(newNode, tagElm.nextSibling)\r\n        return newNode\r\n    },\r\n\r\n    // compares all \"__originalData\" property values with the current \"tagData\" properties\r\n    // and returns \"true\" if something changed.\r\n    editTagChangeDetected(tagData) {\r\n        var originalData = tagData.__originalData;\r\n\r\n        for( var prop in originalData )\r\n            if( !this.dataProps.includes(prop) && tagData[prop] != originalData[prop] )\r\n                return true\r\n\r\n        return false; // not changed\r\n    },\r\n\r\n    // returns the node which has the actual tag's content\r\n    getTagTextNode(tagElm){\r\n        return tagElm.querySelector(this.settings.classNames.tagTextSelector)\r\n    },\r\n\r\n    // sets the text of a tag\r\n    setTagTextNode(tagElm, HTML){\r\n        this.getTagTextNode(tagElm).innerHTML = escapeHTML(HTML)\r\n    },\r\n\r\n    /**\r\n     * Enters a tag into \"edit\" mode\r\n     * @param {Node} tagElm the tag element to edit. if nothing specified, use last last\r\n     */\r\n    editTag( tagElm, opts ){\r\n        tagElm = tagElm || this.getLastTag()\r\n        opts = opts || {}\r\n\r\n        var _s = this.settings,\r\n            editableElm = this.getTagTextNode(tagElm),\r\n            tagIdx = this.getNodeIndex(tagElm),\r\n            tagData = getSetTagData(tagElm),\r\n            _CB = this.events.callbacks,\r\n            isValid = true,\r\n            isSelectMode = _s.mode == 'select'\r\n\r\n        // select mode is a bit different as clicking the tagify's content once will get into edit-mode if a value\r\n        // is already selected, and there cannot be a dropdown already open at this point.\r\n        !isSelectMode && this.dropdown.hide()\r\n\r\n        if( !editableElm ){\r\n            logger.warn('Cannot find element in Tag template: .', _s.classNames.tagTextSelector);\r\n            return;\r\n        }\r\n\r\n        if( tagData instanceof Object && \"editable\" in tagData && !tagData.editable )\r\n            return\r\n\r\n        // cache the original data, on the DOM node, before any modification ocurs, for possible revert\r\n        tagData = getSetTagData(tagElm, {\r\n            __originalData: extend({}, tagData),\r\n            __originalHTML: tagElm.cloneNode(true)\r\n        })\r\n        // re-set the tagify custom-prop on the clones element (because cloning removed it)\r\n        getSetTagData(tagData.__originalHTML, tagData.__originalData)\r\n\r\n        editableElm.setAttribute('contenteditable', true)\r\n        tagElm.classList.add( _s.classNames.tagEditing )\r\n\r\n        editableElm.addEventListener('click'            , _CB.onEditTagClick.bind(this, tagElm))\r\n        editableElm.addEventListener('blur'             , _CB.onEditTagBlur.bind(this, this.getTagTextNode(tagElm)))\r\n        editableElm.addEventListener('input'            , _CB.onEditTagInput.bind(this, editableElm))\r\n        editableElm.addEventListener('paste'            , _CB.onEditTagPaste.bind(this, editableElm))\r\n        editableElm.addEventListener('keydown'          , e => _CB.onEditTagkeydown.call(this, e, tagElm))\r\n        editableElm.addEventListener('compositionstart' , _CB.onCompositionStart.bind(this))\r\n        editableElm.addEventListener('compositionend'   , _CB.onCompositionEnd.bind(this))\r\n\r\n        if( !opts.skipValidation )\r\n            isValid = this.editTagToggleValidity(tagElm)\r\n\r\n        editableElm.originalIsValid = isValid\r\n\r\n        this.trigger(\"edit:start\", { tag:tagElm, index:tagIdx, data:tagData, isValid })\r\n\r\n        editableElm.focus()\r\n        !isSelectMode && this.setRangeAtStartEnd(false, editableElm) // place the caret at the END of the editable tag text\r\n\r\n        _s.dropdown.enabled === 0 && !isSelectMode && this.dropdown.show()\r\n        this.state.hasFocus = true\r\n\r\n        return this\r\n    },\r\n\r\n    /**\r\n     * If a tag is invalid, for any reason, set its class to \"not allowed\" (see defaults file)\r\n     * @param {Node} tagElm required\r\n     * @param {Object} tagData optional\r\n     * @returns true if valid, a string (reason) if not\r\n     */\r\n    editTagToggleValidity( tagElm, tagData ){\r\n        var tagData = tagData || getSetTagData(tagElm),\r\n            isValid;\r\n\r\n        if( !tagData ){\r\n            logger.warn(\"tag has no data: \", tagElm, tagData)\r\n            return;\r\n        }\r\n\r\n        isValid = !(\"__isValid\" in tagData) || tagData.__isValid === true\r\n\r\n        if( !isValid ){\r\n            this.removeTagsFromValue(tagElm)\r\n        }\r\n\r\n        this.update()\r\n\r\n        //this.validateTag(tagData);\r\n\r\n        tagElm.classList.toggle(this.settings.classNames.tagNotAllowed, !isValid)\r\n        tagData.__isValid = isValid;\r\n\r\n        return tagData.__isValid\r\n    },\r\n\r\n    onEditTagDone(tagElm, tagData){\r\n        tagElm = tagElm || this.state.editing.scope\r\n        tagData = tagData || {}\r\n\r\n        var eventData = {\r\n            tag         : tagElm,\r\n            index       : this.getNodeIndex(tagElm),\r\n            previousData: getSetTagData(tagElm),\r\n            data        : tagData\r\n        }\r\n\r\n        var _s = this.settings\r\n\r\n        this.trigger(\"edit:beforeUpdate\", eventData, {cloneData:false})\r\n\r\n        this.state.editing = false;\r\n\r\n        delete tagData.__originalData\r\n        delete tagData.__originalHTML\r\n\r\n        // some scenarrios like in the one in the demos page with textarea that has 2 whitelists, one of the whitelist might be\r\n        // an array of objects with a property defined the same as the `tagTextProp` setting (if used) but another whitelist\r\n        // might be simpler - just an array of primitives.\r\n        function veryfyTagTextProp() {\r\n            var tagTextProp = tagData[_s.tagTextProp];\r\n\r\n            // 'tagTextProp' might also be the number 0 so checking for `undefined` here:\r\n            if( tagTextProp !== undefined ) {\r\n                tagTextProp += ''; // cast possible number into a string\r\n                return !!tagTextProp.trim?.()\r\n            }\r\n\r\n            if( !(_s.tagTextProp in tagData) )\r\n                return !!tagData.value\r\n        }\r\n\r\n        if( tagElm && veryfyTagTextProp() ){\r\n            tagElm = this.replaceTag(tagElm, tagData)\r\n            this.editTagToggleValidity(tagElm, tagData)\r\n\r\n            if( _s.a11y.focusableTags )\r\n                tagElm.focus()\r\n            else if( _s.mode != 'select' )\r\n                // place caret after edited tag\r\n                placeCaretAfterNode(tagElm)\r\n        }\r\n\r\n        else if(tagElm)\r\n            this.removeTags(tagElm)\r\n\r\n        this.trigger(\"edit:updated\", eventData)\r\n        this.dropdown.hide()\r\n\r\n        // check if any of the current tags which might have been marked as \"duplicate\" should be now un-marked\r\n        if( this.settings.keepInvalidTags )\r\n            this.reCheckInvalidTags()\r\n    },\r\n\r\n    /**\r\n     * Replaces an exisitng tag with a new one. Used for updating a tag's data\r\n     * @param {Object} tagElm  [DOM node to replace]\r\n     * @param {Object} tagData [data to create new tag from]\r\n     */\r\n    replaceTag(tagElm, tagData){\r\n        if( !tagData || tagData.value === '' || tagData.value === undefined )\r\n            tagData = tagElm.__tagifyTagData\r\n\r\n        // if tag is invalid, make the according changes in the newly created element\r\n        if( tagData.__isValid && tagData.__isValid != true )\r\n            extend( tagData, this.getInvalidTagAttrs(tagData, tagData.__isValid) )\r\n\r\n        var newTagElm = this.createTagElem(tagData)\r\n\r\n        // update DOM\r\n        tagElm.parentNode.replaceChild(newTagElm, tagElm)\r\n        this.updateValueByDOMTags()\r\n        return newTagElm\r\n    },\r\n\r\n    /**\r\n     * update \"value\" (Array of Objects) by traversing all valid tags\r\n     */\r\n    updateValueByDOMTags(){\r\n        this.value.length = 0;\r\n\r\n        [].forEach.call(this.getTagElms(), node => {\r\n            if( node.classList.contains(this.settings.classNames.tagNotAllowed.split(' ')[0]) ) return\r\n            this.value.push( getSetTagData(node) )\r\n        })\r\n\r\n        this.update()\r\n    },\r\n\r\n    /**\r\n     * injects nodes/text at caret position, which is saved on the \"state\" when \"blur\" event gets triggered\r\n     * @param {Node} injectedNode [the node to inject at the caret position]\r\n     * @param {Object} selection [optional range Object. must have \"anchorNode\" & \"anchorOffset\"]\r\n     */\r\n    injectAtCaret( injectedNode, range ){\r\n        range = range || this.state.selection?.range\r\n\r\n        if( !range && injectedNode ) {\r\n            this.appendMixTags(injectedNode)\r\n            return this;\r\n        }\r\n\r\n        let node = injectAtCaret(injectedNode, range)\r\n        this.setRangeAtStartEnd(false, node)\r\n\r\n        this.updateValueByDOMTags() // updates internal \"this.value\"\r\n        this.update() // updates original input/textarea\r\n\r\n        return this\r\n    },\r\n\r\n    /**\r\n     * input bridge for accessing & setting\r\n     * @type {Object}\r\n     */\r\n    input : {\r\n        set( s = '', updateDOM = true ){\r\n            var hideDropdown = this.settings.dropdown.closeOnSelect\r\n            this.state.inputText = s\r\n\r\n            if( updateDOM )\r\n                this.DOM.input.innerHTML = escapeHTML(\"\"+s);\r\n\r\n            if( !s && hideDropdown )\r\n                this.dropdown.hide.bind(this)\r\n\r\n            this.input.autocomplete.suggest.call(this);\r\n            this.input.validate.call(this);\r\n        },\r\n\r\n        raw(){\r\n            return this.DOM.input.textContent\r\n        },\r\n\r\n        /**\r\n         * Marks the tagify's input as \"invalid\" if the value did not pass \"validateTag()\"\r\n         */\r\n        validate(){\r\n            var isValid = !this.state.inputText || this.validateTag({value:this.state.inputText}) === true;\r\n\r\n            this.DOM.input.classList.toggle(this.settings.classNames.inputInvalid, !isValid)\r\n\r\n            return isValid\r\n        },\r\n\r\n        // remove any child DOM elements that aren't of type TEXT (like <br>)\r\n        normalize( node, options ){\r\n            var clone = node || this.DOM.input, //.cloneNode(true),\r\n                v = [];\r\n\r\n            // when a text was pasted in FF, the \"this.DOM.input\" element will have <br> but no newline symbols (\\n), and this will\r\n            // result in tags not being properly created if one wishes to create a separate tag per newline.\r\n            clone.childNodes.forEach(n => n.nodeType==3 && v.push(n.nodeValue))\r\n            v = v.join(\"\\n\")\r\n\r\n            try{\r\n                // \"delimiters\" might be of a non-regex value, where this will fail (\"Tags With Properties\" example in demo page):\r\n                v = v.replace(/(?:\\r\\n|\\r|\\n)/g, this.settings.delimiters.source.charAt(0))\r\n            }\r\n            catch(err){}\r\n\r\n            v = v.replace(/\\s/g, ' ')  // replace NBSPs with spaces characters\r\n\r\n            return options?.trim ? this.trim(v) : v\r\n        },\r\n\r\n        /**\r\n         * suggest the rest of the input's value (via CSS \"::after\" using \"content:attr(...)\")\r\n         * @param  {String} s [description]\r\n         */\r\n        autocomplete : {\r\n            suggest( data ){\r\n                if( !this.settings.autoComplete.enabled ) return;\r\n\r\n                data = data || {value:''}\r\n                if (typeof data !== 'object') data = { value: data };\r\n\r\n                var suggestedText = this.dropdown.getMappedValue(data);\r\n\r\n                if( typeof suggestedText === 'number' ) return\r\n\r\n                var inputText = this.state.inputText.toLowerCase(),\r\n                    suggestionStart = suggestedText.substr(0, this.state.inputText.length).toLowerCase(),\r\n                    suggestionTrimmed = suggestedText.substring(this.state.inputText.length);\r\n\r\n                if( !suggestedText || !this.state.inputText || suggestionStart != inputText ){\r\n                    this.DOM.input.removeAttribute(\"data-suggest\");\r\n                    delete this.state.inputSuggestion\r\n                }\r\n                else{\r\n                    this.DOM.input.setAttribute(\"data-suggest\", suggestionTrimmed);\r\n                    this.state.inputSuggestion = data\r\n                }\r\n            },\r\n\r\n            /**\r\n             * sets the suggested text as the input's value & cleanup the suggestion autocomplete.\r\n             * @param {String} s [text]\r\n             */\r\n            set( s ){\r\n                var dataSuggest = this.DOM.input.getAttribute('data-suggest'),\r\n                    suggestion = s || (dataSuggest ? this.state.inputText + dataSuggest : null);\r\n\r\n                if( suggestion ){\r\n                    if( this.settings.mode == 'mix' ){\r\n                        this.replaceTextWithNode( document.createTextNode(this.state.tag.prefix + suggestion) )\r\n                    }\r\n                    else{\r\n                        this.input.set.call(this, suggestion);\r\n                        this.setRangeAtStartEnd(false, this.DOM.input)\r\n                    }\r\n\r\n                    this.input.autocomplete.suggest.call(this);\r\n                    this.dropdown.hide();\r\n\r\n                    return true;\r\n                }\r\n\r\n                return false;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * returns the index of the the tagData within the \"this.value\" array collection.\r\n     * since values should be unique, it is suffice to only search by \"value\" property\r\n     * @param {Object} tagData\r\n     */\r\n    getTagIdx( tagData ){\r\n        return this.value.findIndex(item => item.__tagId == (tagData||{}).__tagId )\r\n    },\r\n\r\n    getNodeIndex( node ){\r\n        var index = 0;\r\n\r\n        if( node )\r\n            while( (node = node.previousElementSibling) )\r\n                index++;\r\n\r\n        return index;\r\n    },\r\n\r\n    getTagElms( ...classess ){\r\n        var classname = '.' + [...this.settings.classNames.tag.split(' '), ...classess].join('.')\r\n        return [].slice.call(this.DOM.scope.querySelectorAll(classname)) // convert nodeList to Array - https://stackoverflow.com/a/3199627/104380\r\n    },\r\n\r\n    /**\r\n     * gets the last non-readonly, not-in-the-proccess-of-removal tag\r\n     */\r\n    getLastTag(){\r\n        var _sc = this.settings.classNames,\r\n            tagNodes = this.DOM.scope.querySelectorAll(`${_sc.tagSelector}:not(.${_sc.tagHide}):not([readonly])`);\r\n        return tagNodes[tagNodes.length - 1];\r\n    },\r\n\r\n    /**\r\n     * Searches if any tag with a certain value already exis\r\n     * @param  {String/Object} value [text value / tag data object]\r\n     * @param  {Boolean} caseSensitive\r\n     * @return {Number}\r\n     */\r\n    isTagDuplicate( value, caseSensitive, tagId ){\r\n        var dupsCount = 0,\r\n            _s = this.settings;\r\n\r\n        // duplications are irrelevant for this scenario\r\n        if( _s.mode == 'select' )\r\n            return false\r\n\r\n        for( let item of this.value ) {\r\n            let isSameStr = sameStr( this.trim(\"\"+value), item.value, caseSensitive );\r\n            if( isSameStr && tagId != item.__tagId )\r\n                dupsCount++;\r\n        }\r\n\r\n        return dupsCount\r\n    },\r\n\r\n    getTagIndexByValue( value ){\r\n        var indices = [],\r\n            isCaseSensitive = this.settings.dropdown.caseSensitive;\r\n\r\n        this.getTagElms().forEach((tagElm, i) => {\r\n            if(  tagElm.__tagifyTagData && sameStr( this.trim(tagElm.__tagifyTagData.value), value, isCaseSensitive )  )\r\n                indices.push(i)\r\n        })\r\n\r\n        return indices;\r\n    },\r\n\r\n    getTagElmByValue( value ){\r\n        var tagIdx = this.getTagIndexByValue(value)[0]\r\n        return this.getTagElms()[tagIdx]\r\n    },\r\n\r\n    /**\r\n     * Temporarily marks a tag element (by value or Node argument)\r\n     * @param  {Object} tagElm [a specific \"tag\" element to compare to the other tag elements siblings]\r\n     */\r\n    flashTag( tagElm ){\r\n        if( tagElm ){\r\n            tagElm.classList.add(this.settings.classNames.tagFlash)\r\n            setTimeout(() => { tagElm.classList.remove(this.settings.classNames.tagFlash) }, 100)\r\n        }\r\n    },\r\n\r\n    /**\r\n     * checks if text is in the blacklist\r\n     */\r\n    isTagBlacklisted( v ){\r\n        v = this.trim(v.toLowerCase());\r\n        return this.settings.blacklist.filter(x => (\"\"+x).toLowerCase() == v).length;\r\n    },\r\n\r\n    /**\r\n     * checks if text is in the whitelist\r\n     */\r\n    isTagWhitelisted( v ){\r\n        return !!this.getWhitelistItem(v)\r\n        /*\r\n        return this.settings.whitelist.some(item =>\r\n            typeof v == 'string'\r\n                ? sameStr(this.trim(v), (item.value || item))\r\n                : sameStr(JSON.stringify(item), JSON.stringify(v))\r\n        )\r\n        */\r\n    },\r\n\r\n    /**\r\n     * Returns the first whitelist item matched, by value (if match found)\r\n     * @param {String} value [text to match by]\r\n     */\r\n    getWhitelistItem( value, prop, whitelist ){\r\n        var result,\r\n            prop = prop || 'value',\r\n            _s = this.settings,\r\n            whitelist = whitelist || _s.whitelist;\r\n\r\n        whitelist.some(_wi => {\r\n            // whitelist item value. Can be either a String, Number or an Object (with a `value` property)\r\n            var _wiv = typeof _wi == 'object' ? (_wi[prop] || _wi.value) : _wi,\r\n                isSameStr = sameStr(_wiv, value, _s.dropdown.caseSensitive, _s.trim)\r\n\r\n            if( isSameStr ){\r\n                result = typeof _wi == 'object' ? _wi : {value:_wi}\r\n                return true\r\n            }\r\n        })\r\n\r\n        // first iterate the whitelist, try find matches by \"value\" and if that fails\r\n        // and a \"tagTextProp\" is set to be other than \"value\", try that also\r\n        if( !result && prop == 'value' && _s.tagTextProp != 'value' ){\r\n            // if found, adds the first which matches\r\n            result = this.getWhitelistItem(value, _s.tagTextProp, whitelist)\r\n        }\r\n\r\n        return result\r\n    },\r\n\r\n    /**\r\n     * validate a tag object BEFORE the actual tag will be created & appeneded\r\n     * @param  {String} s\r\n     * @param  {String} uid      [unique ID, to not inclue own tag when cheking for duplicates]\r\n     * @return {Boolean/String}  [\"true\" if validation has passed, String for a fail]\r\n     */\r\n    validateTag( tagData ){\r\n        var _s = this.settings,\r\n            // when validating a tag in edit-mode, need to take \"tagTextProp\" into consideration\r\n            prop = \"value\" in tagData ? \"value\" : _s.tagTextProp,\r\n            v = this.trim(tagData[prop] + \"\");\r\n\r\n        // check for definitive empty value\r\n        if( !(tagData[prop]+\"\").trim() )\r\n            return this.TEXTS.empty;\r\n\r\n        // check if pattern should be used and if so, use it to test the value\r\n        if( _s.mode != 'mix' && _s.pattern && _s.pattern instanceof RegExp && !(_s.pattern.test(v)) )\r\n            return this.TEXTS.pattern;\r\n\r\n        // check for duplicates\r\n        if( !_s.duplicates && this.isTagDuplicate(v, _s.dropdown.caseSensitive, tagData.__tagId) )\r\n            return this.TEXTS.duplicate;\r\n\r\n        if( this.isTagBlacklisted(v) || (_s.enforceWhitelist && !this.isTagWhitelisted(v)) )\r\n            return this.TEXTS.notAllowed;\r\n\r\n        if( _s.validate )\r\n            return _s.validate(tagData)\r\n\r\n        return true\r\n    },\r\n\r\n    getInvalidTagAttrs(tagData, validation){\r\n        return {\r\n            \"aria-invalid\" : true,\r\n            \"class\": `${tagData.class || ''} ${this.settings.classNames.tagNotAllowed}`.trim(),\r\n            \"title\": validation\r\n        }\r\n    },\r\n\r\n    hasMaxTags(){\r\n        return this.value.length >= this.settings.maxTags\r\n            ? this.TEXTS.exceed\r\n            : false\r\n    },\r\n\r\n    setReadonly( toggle, attrribute ){\r\n        var _s = this.settings\r\n\r\n        this.DOM.scope.contains(document.activeElement) && document.activeElement.blur() // exit possible edit-mode\r\n        _s[attrribute || 'readonly'] = toggle\r\n        this.DOM.scope[(toggle ? 'set' : 'remove') + 'Attribute'](attrribute || 'readonly', true)\r\n\r\n        this.settings.userInput = true;\r\n        this.setContentEditable(!toggle)\r\n    },\r\n\r\n    setContentEditable(state){\r\n        this.DOM.input.contentEditable = state\r\n        this.DOM.input.tabIndex = !!state ? 0 : -1;\r\n    },\r\n\r\n    setDisabled( isDisabled ){\r\n        this.setReadonly(isDisabled, 'disabled')\r\n    },\r\n\r\n    /**\r\n     * pre-proccess the tagsItems, which can be a complex tagsItems like an Array of Objects or a string comprised of multiple words\r\n     * so each item should be iterated on and a tag created for.\r\n     * @return {Array} [Array of Objects]\r\n     */\r\n    normalizeTags( tagsItems ){\r\n        var {whitelist, delimiters, mode, tagTextProp} = this.settings,\r\n            whitelistMatches = [],\r\n            whitelistWithProps = whitelist ? whitelist[0] instanceof Object : false,\r\n            // checks if this is a \"collection\", meanning an Array of Objects\r\n            isArray = Array.isArray(tagsItems),\r\n            isCollection = isArray && tagsItems[0].value,\r\n            mapStringToCollection = s => (s+\"\").split(delimiters).reduce((acc, v) => {\r\n                const trimmed = this.trim(v)\r\n                trimmed && acc.push({ [tagTextProp]:trimmed, value:trimmed })\r\n                return acc\r\n            }, [])\r\n\r\n        if( typeof tagsItems == 'number' )\r\n            tagsItems = tagsItems.toString()\r\n\r\n        // if the argument is a \"simple\" String, ex: \"aaa, bbb, ccc\"\r\n        if( typeof tagsItems == 'string' ){\r\n            if( !tagsItems.trim() ) return [];\r\n\r\n            // go over each tag and add it (if there were multiple ones)\r\n            tagsItems = mapStringToCollection(tagsItems)\r\n        }\r\n\r\n        // if is an Array of Strings, convert to an Array of Objects\r\n        else if( isArray ){\r\n            // flatten the 2D array\r\n            tagsItems = tagsItems.reduce((acc, item) => {\r\n                if( isObject(item) ) {\r\n                    var itemCopy = extend({}, item)\r\n                    itemCopy[tagTextProp] = this.trim(itemCopy[tagTextProp])\r\n\r\n                    // discard empty tags\r\n                    if( itemCopy[tagTextProp] )\r\n                        acc.push(itemCopy) // mapStringToCollection(item.value).map(newItem => ({...item,...newItem}))\r\n                }\r\n\r\n                else if(item) {\r\n                    acc.push( ...mapStringToCollection(item) )\r\n                }\r\n\r\n                return acc\r\n            }, [])\r\n        }\r\n\r\n        // search if the tag exists in the whitelist as an Object (has props),\r\n        // to be able to use its properties.\r\n        // skip matching collections with whitelist items as they are considered \"whole\"\r\n        if( whitelistWithProps && !isCollection ){\r\n            tagsItems.forEach(item => {\r\n                var whitelistMatchesValues = whitelistMatches.map(a=>a.value)\r\n\r\n                // if suggestions are shown, they are already filtered, so it's easier to use them,\r\n                // because the whitelist might also include items which have already been added\r\n                var filteredList = this.dropdown.filterListItems.call(this, item[tagTextProp], { exact:true })\r\n\r\n                if( !this.settings.duplicates )\r\n                    // also filter out items which have already been matched in previous iterations\r\n                    filteredList = filteredList.filter(filteredItem => !whitelistMatchesValues.includes(filteredItem.value))\r\n\r\n                // get the best match out of list of possible matches.\r\n                // if there was a single item in the filtered list, use that one\r\n                var matchObj = filteredList.length > 1\r\n                    ? this.getWhitelistItem(item[tagTextProp], tagTextProp, filteredList)\r\n                    : filteredList[0]\r\n\r\n                if( matchObj && matchObj instanceof Object ){\r\n                    whitelistMatches.push( matchObj ) // set the Array (with the found Object) as the new value\r\n                }\r\n                else if( mode != 'mix' ){\r\n                    if( item.value == undefined )\r\n                        item.value = item[tagTextProp]\r\n                    whitelistMatches.push(item)\r\n                }\r\n            })\r\n\r\n            if( whitelistMatches.length )\r\n                tagsItems = whitelistMatches\r\n        }\r\n\r\n        return tagsItems;\r\n    },\r\n\r\n    /**\r\n     * Parse the initial value of a textarea (or input) element and generate mixed text w/ tags\r\n     * https://stackoverflow.com/a/57598892/104380\r\n     * @param {String} s\r\n     */\r\n    parseMixTags( s ){\r\n        var {mixTagsInterpolator, duplicates, transformTag, enforceWhitelist, maxTags, tagTextProp} = this.settings,\r\n            tagsDataSet = [];\r\n\r\n        s = s.split(mixTagsInterpolator[0]).map((s1, i) => {\r\n            var s2 = s1.split(mixTagsInterpolator[1]),\r\n                preInterpolated = s2[0],\r\n                maxTagsReached = tagsDataSet.length == maxTags,\r\n                textProp,\r\n                tagData,\r\n                tagElm;\r\n\r\n            try{\r\n                // skip numbers and go straight to the \"catch\" statement\r\n                if( preInterpolated == +preInterpolated )\r\n                    throw Error\r\n                tagData = JSON.parse(preInterpolated)\r\n            } catch(err){\r\n                tagData = this.normalizeTags(preInterpolated)[0] || {value:preInterpolated}\r\n            }\r\n\r\n            transformTag.call(this, tagData)\r\n\r\n            if( !maxTagsReached   &&\r\n                s2.length > 1   &&\r\n                (!enforceWhitelist || this.isTagWhitelisted(tagData.value))   &&\r\n                !(!duplicates && this.isTagDuplicate(tagData.value)) ){\r\n\r\n                // in case \"tagTextProp\" setting is set to other than \"value\" and this tag does not have this prop\r\n                textProp = tagData[tagTextProp] ? tagTextProp : 'value'\r\n                tagData[textProp] = this.trim(tagData[textProp])\r\n\r\n                tagElm = this.createTagElem(tagData)\r\n                tagsDataSet.push( tagData )\r\n                tagElm.classList.add(this.settings.classNames.tagNoAnimation)\r\n\r\n                s2[0] = tagElm.outerHTML //+ \"&#8288;\"  // put a zero-space at the end so the caret won't jump back to the start (when the last input's child element is a tag)\r\n                this.value.push(tagData)\r\n            }\r\n            else if(s1)\r\n                return i ? mixTagsInterpolator[0] + s1 : s1\r\n\r\n            return s2.join('')\r\n        }).join('')\r\n\r\n        this.DOM.input.innerHTML = s\r\n        this.DOM.input.appendChild(document.createTextNode(''))\r\n        this.DOM.input.normalize()\r\n\r\n        var tagNodes = this.getTagElms()\r\n\r\n        tagNodes.forEach((elm, idx) => getSetTagData(elm,  tagsDataSet[idx]))\r\n        this.update({withoutChangeEvent:true})\r\n\r\n        fixCaretBetweenTags(tagNodes, this.state.hasFocus)\r\n        return s\r\n    },\r\n\r\n    /**\r\n     * For mixed-mode: replaces a text starting with a prefix with a wrapper element (tag or something)\r\n     * First there *has* to be a \"this.state.tag\" which is a string that was just typed and is staring with a prefix\r\n     */\r\n    replaceTextWithNode( newWrapperNode, strToReplace ){\r\n        if( !this.state.tag && !strToReplace ) return;\r\n\r\n        strToReplace = strToReplace || this.state.tag.prefix + this.state.tag.value;\r\n        var idx, nodeToReplace,\r\n            selection = this.state.selection || window.getSelection(),\r\n            nodeAtCaret = selection.anchorNode,\r\n            firstSplitOffset = this.state.tag.delimiters ? this.state.tag.delimiters.length : 0;\r\n\r\n        // STEP 1: ex. replace #ba with the tag \"bart\" where \"|\" is where the caret is:\r\n        // CURRENT STATE: \"foo #ba #ba| #ba\"\r\n\r\n        // split the text node at the index of the caret\r\n        nodeAtCaret.splitText(selection.anchorOffset - firstSplitOffset)\r\n\r\n        // node 0: \"foo #ba #ba|\"\r\n        // node 1: \" #ba\"\r\n\r\n        // get index of LAST occurence of \"#ba\"\r\n        idx = nodeAtCaret.nodeValue.lastIndexOf(strToReplace)\r\n\r\n        if( idx == -1 ) return true;\r\n\r\n        nodeToReplace = nodeAtCaret.splitText(idx)\r\n\r\n        // node 0: \"foo #ba \"\r\n        // node 1: \"#ba\"    <- nodeToReplace\r\n\r\n        newWrapperNode && nodeAtCaret.parentNode.replaceChild(newWrapperNode, nodeToReplace)\r\n\r\n        // must NOT normalize contenteditable or it will cause unwanted issues:\r\n        // https://monosnap.com/file/ZDVmRvq5upYkidiFedvrwzSswegWk7\r\n        // nodeAtCaret.parentNode.normalize()\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Validate a tag's data and create a new tag node\r\n     * @param {*} tagData\r\n     * @param {*} options\r\n     * @returns Object\r\n     */\r\n    prepareNewTagNode(tagData, options) {\r\n        options = options || {}\r\n\r\n        var tagElm,\r\n            _s = this.settings,\r\n            aggregatedInvalidInput = [],\r\n            tagElmParams = {},\r\n            originalData = Object.assign({}, tagData, {value:tagData.value+\"\"});\r\n\r\n        // shallow-clone tagData so later modifications will not apply to the source\r\n        tagData = Object.assign({}, originalData)\r\n        _s.transformTag.call(this, tagData)\r\n\r\n        tagData.__isValid = this.hasMaxTags() || this.validateTag(tagData)\r\n\r\n        if( tagData.__isValid !== true ){\r\n            if( options.skipInvalid )\r\n                return\r\n\r\n            // originalData is kept because it might be that this tag is invalid because it is a duplicate of another,\r\n            // and if that other tags is edited/deleted, this one should be re-validated and if is no more a duplicate - restored\r\n            extend(tagElmParams, this.getInvalidTagAttrs(tagData, tagData.__isValid), {__preInvalidData:originalData})\r\n\r\n            if( tagData.__isValid == this.TEXTS.duplicate )\r\n                // mark, for a brief moment, the tag (this this one) which THIS CURRENT tag is a duplcate of\r\n                this.flashTag( this.getTagElmByValue(tagData.value) )\r\n\r\n            if( !_s.createInvalidTags ){\r\n                aggregatedInvalidInput.push(tagData.value)\r\n                return\r\n            }\r\n        }\r\n\r\n        if( 'readonly' in tagData ){\r\n            if( tagData.readonly )\r\n                tagElmParams[\"aria-readonly\"] = true\r\n            // if \"readonly\" is \"false\", remove it from the tagData so it won't be added as an attribute in the template\r\n            else\r\n                delete tagData.readonly\r\n        }\r\n\r\n        // Create tag HTML element\r\n        tagElm = this.createTagElem(tagData, tagElmParams)\r\n\r\n        return {tagElm, tagData, aggregatedInvalidInput}\r\n    },\r\n\r\n    /**\r\n     * Logic to happen once a tag has just been injected into the DOM\r\n     * @param {Node} tagElm\r\n     * @param {Object} tagData\r\n     */\r\n    postProcessNewTagNode(tagElm, tagData) {\r\n        var _s = this.settings,\r\n            isValid = tagData.__isValid;\r\n\r\n        if( isValid && isValid === true ){\r\n            // update state\r\n            this.value.push(tagData)\r\n            this.trigger('add', {tag:tagElm, index:this.value.length - 1, data:tagData})\r\n        }\r\n        else{\r\n            this.trigger('invalid', {data:tagData, index:this.value.length, tag:tagElm, message:isValid})\r\n            if( !_s.keepInvalidTags )\r\n                // remove invalid tags (if \"keepInvalidTags\" is set to \"false\")\r\n                setTimeout(() => this.removeTags(tagElm, true), 1000)\r\n        }\r\n\r\n        this.dropdown.position() // reposition the dropdown because the just-added tag might cause a new-line\r\n    },\r\n\r\n    /**\r\n     * For selecting a single option (not used for multiple tags, but for \"mode:select\" only)\r\n     * @param {Object} tagElm   Tag DOM node\r\n     * @param {Object} tagData  Tag data\r\n     */\r\n    selectTag( tagElm, tagData ){\r\n        var _s = this.settings\r\n\r\n        if( _s.enforceWhitelist && !this.isTagWhitelisted(tagData.value) )\r\n            return\r\n\r\n        // this.input.set.call(this, tagData[_s.tagTextProp] || tagData.value, true)\r\n\r\n        // place the caret at the end of the input, only if a dropdown option was selected (and not by manually typing another value and clicking \"TAB\")\r\n        if( this.state.actions.selectOption )\r\n            setTimeout(() => this.setRangeAtStartEnd(false, this.DOM.input))\r\n\r\n        var lastTagElm = this.getLastTag()\r\n\r\n        if( lastTagElm )\r\n            this.replaceTag(lastTagElm, tagData)\r\n        else\r\n            this.appendTag(tagElm)\r\n\r\n        // if( _s.enforceWhitelist )\r\n        //     this.setContentEditable(false);\r\n\r\n        this.value[0] = tagData\r\n        this.update()\r\n        this.trigger('add', { tag:tagElm, data:tagData })\r\n\r\n        return [tagElm]\r\n    },\r\n\r\n    /**\r\n     * add an empty \"tag\" element in an editable state\r\n     */\r\n    addEmptyTag( initialData ){\r\n        var tagData = extend({ value:\"\" }, initialData || {}),\r\n            tagElm = this.createTagElem(tagData)\r\n\r\n        getSetTagData(tagElm, tagData)\r\n\r\n        // add the tag to the component's DOM\r\n        this.appendTag(tagElm)\r\n        this.editTag(tagElm, {skipValidation:true})\r\n        this.toggleFocusClass(true)\r\n    },\r\n\r\n    /**\r\n     * add a \"tag\" element to the \"tags\" component\r\n     * @param {String/Array} tagsItems   [A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings]\r\n     * @param {Boolean}      clearInput  [flag if the input's value should be cleared after adding tags]\r\n     * @param {Boolean}      skipInvalid [do not add, mark & remove invalid tags]\r\n     * @return {Array} Array of DOM elements (tags)\r\n     */\r\n    addTags( tagsItems, clearInput, skipInvalid ){\r\n        var tagElems = [],\r\n            _s = this.settings,\r\n            aggregatedInvalidInput = [],\r\n            frag = document.createDocumentFragment()\r\n\r\n        if( !tagsItems || tagsItems.length == 0 ){\r\n            return tagElems\r\n        }\r\n\r\n        // converts Array/String/Object to an Array of Objects\r\n        tagsItems = this.normalizeTags(tagsItems)\r\n\r\n        switch( _s.mode ){\r\n            case 'mix': return this.addMixTags(tagsItems)\r\n            case 'select': {\r\n                clearInput = false\r\n                this.removeAllTags()\r\n            }\r\n        }\r\n\r\n        this.DOM.input.removeAttribute('style')\r\n\r\n        tagsItems.forEach(tagData => {\r\n            const newTagNode = this.prepareNewTagNode(tagData, {skipInvalid: skipInvalid || _s.skipInvalid});\r\n\r\n            if( !newTagNode) return;\r\n\r\n            const tagElm = newTagNode.tagElm;\r\n\r\n            tagData = newTagNode.tagData\r\n            aggregatedInvalidInput = newTagNode.aggregatedInvalidInput\r\n\r\n            tagElems.push(tagElm)\r\n\r\n            // mode-select overrides\r\n            if( _s.mode == 'select' ){\r\n                return this.selectTag(tagElm, tagData)\r\n            }\r\n\r\n            // add the tag to the component's DOM\r\n            // this.appendTag(tagElm)\r\n            frag.appendChild(tagElm)\r\n\r\n            this.postProcessNewTagNode(tagElm, tagData)\r\n        })\r\n\r\n        this.appendTag(frag)\r\n        this.update()\r\n\r\n        if( tagsItems.length && clearInput ){\r\n            this.input.set.call(this, _s.createInvalidTags ? '' : aggregatedInvalidInput.join(_s._delimiters))\r\n            this.setRangeAtStartEnd(false, this.DOM.input)\r\n        }\r\n\r\n        _s.dropdown.enabled && this.dropdown.refilter()\r\n        return tagElems\r\n    },\r\n\r\n    /**\r\n     * Adds a mix-content tag\r\n     * @param {String/Array} tagData    A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings\r\n     */\r\n    addMixTags( tagsData ){\r\n        tagsData = this.normalizeTags(tagsData);\r\n\r\n        // flow for creating custom tags which aren't a part of the whitelist\r\n        if( tagsData[0].prefix || this.state.tag ){\r\n            return this.prefixedTextToTag(tagsData[0])\r\n        }\r\n\r\n        var frag = document.createDocumentFragment()\r\n\r\n        tagsData.forEach(tagData => {\r\n            const newTagNode = this.prepareNewTagNode(tagData)\r\n            frag.appendChild(newTagNode.tagElm)\r\n            this.insertAfterTag(newTagNode.tagElm)\r\n            this.postProcessNewTagNode(newTagNode.tagElm, newTagNode.tagData)\r\n        })\r\n\r\n        this.appendMixTags(frag)\r\n\r\n        return frag.children\r\n    },\r\n\r\n    appendMixTags( node ) {\r\n        var selection = !!this.state.selection;\r\n\r\n        // if \"selection\" exists, assumes intention of inecting the new tag at the last\r\n        // saved location of the caret inside \"this.DOM.input\"\r\n        if( selection ){\r\n            this.injectAtCaret(node)\r\n        }\r\n        // else, create a range and inject the new tag as the last child of \"this.DOM.input\"\r\n        else{\r\n            this.DOM.input.focus()\r\n            selection = this.setStateSelection()\r\n            selection.range.setStart(this.DOM.input, selection.range.endOffset)\r\n            selection.range.setEnd(this.DOM.input, selection.range.endOffset)\r\n            this.DOM.input.appendChild(node)\r\n\r\n            this.updateValueByDOMTags() // updates internal \"this.value\"\r\n            this.update() // updates original input/textarea\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds a tag which was activly typed by the user\r\n     * @param {String/Array} tagData   [A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings]\r\n     */\r\n    prefixedTextToTag( tagData ){\r\n        var _s = this.settings,\r\n            tagElm,\r\n            newTag,\r\n            createdFromDelimiters = this.state.tag?.delimiters;\r\n\r\n        tagData.prefix = tagData.prefix || this.state.tag ? this.state.tag.prefix : (_s.pattern.source||_s.pattern)[0];\r\n\r\n        newTag = this.prepareNewTagNode(tagData)\r\n        tagElm = newTag.tagElm\r\n\r\n        // tries to replace a taged textNode with a tagElm, and if not able,\r\n        // insert the new tag to the END if \"addTags\" was called from outside\r\n        if( !this.replaceTextWithNode(tagElm) ){\r\n            this.DOM.input.appendChild(tagElm)\r\n        }\r\n\r\n        setTimeout(()=> tagElm.classList.add(this.settings.classNames.tagNoAnimation), 300)\r\n\r\n        this.value.push(newTag.tagData)\r\n        this.update()\r\n\r\n        if( !createdFromDelimiters ) {\r\n            var elm = this.insertAfterTag(tagElm) || tagElm;\r\n            // a timeout is needed when selecting a tag from the suggestions via mouse.\r\n            // Without it, it seems the caret is placed right after the tag and not after the\r\n            // node which was inserted after the tag (whitespace by default)\r\n            setTimeout(placeCaretAfterNode, 0, elm);\r\n        }\r\n\r\n        this.state.tag = null\r\n\r\n        this.postProcessNewTagNode(tagElm, newTag.tagData)\r\n\r\n        return tagElm\r\n    },\r\n\r\n    /**\r\n     * appened (validated) tag to the component's DOM scope\r\n     */\r\n    appendTag(tagElm){\r\n        var DOM = this.DOM,\r\n            insertBeforeNode = DOM.input;\r\n\r\n        //if( insertBeforeNode === DOM.input )\r\n            DOM.scope.insertBefore(tagElm, insertBeforeNode)\r\n        //else\r\n        //    DOM.scope.appendChild(tagElm)\r\n    },\r\n\r\n    /**\r\n     * creates a DOM tag element and injects it into the component (this.DOM.scope)\r\n     * @param  {Object}  tagData [text value & properties for the created tag]\r\n     * @param  {Object}  extraData [properties which are for the HTML template only]\r\n     * @return {Object} [DOM element]\r\n     */\r\n    createTagElem( tagData, extraData ){\r\n        tagData.__tagId = getUID()\r\n\r\n        var tagElm,\r\n            templateData = extend({}, tagData, { value:escapeHTML(tagData.value+\"\"), ...extraData });\r\n\r\n        // if( this.settings.readonly )\r\n        //     tagData.readonly = true\r\n\r\n        tagElm = this.parseTemplate('tag', [templateData, this])\r\n\r\n        // crucial for proper caret placement when deleting content. if textNodes are allowed as children of a tag element,\r\n        // a browser bug casues the caret to be misplaced inside the tag element (especially affects \"readonly\" tags)\r\n        removeTextChildNodes(tagElm)\r\n        // while( tagElm.lastChild.nodeType == 3 )\r\n        //     tagElm.lastChild.parentNode.removeChild(tagElm.lastChild)\r\n\r\n        getSetTagData(tagElm, tagData)\r\n        return tagElm\r\n    },\r\n\r\n    /**\r\n     * re-check all invalid tags.\r\n     * called after a tag was edited or removed\r\n     */\r\n    reCheckInvalidTags(){\r\n        var _s = this.settings\r\n\r\n        this.getTagElms(_s.classNames.tagNotAllowed).forEach((tagElm, i) => {\r\n            var tagData = getSetTagData(tagElm),\r\n                hasMaxTags = this.hasMaxTags(),\r\n                tagValidation = this.validateTag(tagData),\r\n                isValid = tagValidation === true && !hasMaxTags;\r\n\r\n            if( _s.mode == 'select' )\r\n                this.toggleScopeValidation(tagValidation)\r\n\r\n            // if the tag has become valid\r\n            if( isValid ){\r\n                tagData = tagData.__preInvalidData\r\n                    ? tagData.__preInvalidData\r\n                    : { value:tagData.value }\r\n\r\n                return this.replaceTag(tagElm, tagData)\r\n            }\r\n\r\n            // if the tag is still invaild, set its title as such (reson of invalid might have changed)\r\n            tagElm.title = hasMaxTags || tagValidation\r\n        })\r\n    },\r\n\r\n    /**\r\n     * Removes a tag\r\n     * @param  {Array|Node|String}  tagElms         [DOM element(s) or a String value. if undefined or null, remove last added tag]\r\n     * @param  {Boolean}            silent          [A flag, which when turned on, does not remove any value and does not update the original input value but simply removes the tag from tagify]\r\n     * @param  {Number}             tranDuration    [Transition duration in MS]\r\n     * TODO: Allow multiple tags to be removed at-once\r\n     */\r\n    removeTags( tagElms, silent, tranDuration ){\r\n        var tagsToRemove,\r\n            _s = this.settings;\r\n\r\n        tagElms = tagElms && tagElms instanceof HTMLElement\r\n            ? [tagElms]\r\n            : tagElms instanceof Array\r\n                ? tagElms\r\n                : tagElms\r\n                    ? [tagElms]\r\n                    : [this.getLastTag()].filter(n => n)   // must filter because \"this.getLastTag()\" might be `undefined` if there are not tags\r\n\r\n        // normalize tagElms array values:\r\n        // 1. removing invalid items\r\n        // 2, if an item is String try to get the matching Tag HTML node\r\n        // 3. get the tag data\r\n        // 4. return a collection of Objects\r\n        tagsToRemove = tagElms.reduce((elms, tagElm) => {\r\n            if( tagElm && typeof tagElm == 'string')\r\n                tagElm = this.getTagElmByValue(tagElm)\r\n\r\n            var tagData = getSetTagData(tagElm);\r\n\r\n            if( tagElm && tagData && !tagData.readonly ) // make sure it's a tag and not some other node\r\n                // because the DOM node might be removed by async animation, the state will be updated while\r\n                // the node might still be in the DOM, so the \"update\" method should know which nodes to ignore\r\n                elms.push({\r\n                    node: tagElm,\r\n                    idx: this.getTagIdx(tagData), // this.getNodeIndex(tagElm); // this.getTagIndexByValue(tagElm.textContent)\r\n                    data: getSetTagData(tagElm, {'__removed':true})\r\n                })\r\n\r\n            return elms\r\n        }, [])\r\n\r\n        tranDuration = typeof tranDuration == \"number\" ? tranDuration : this.CSSVars.tagHideTransition\r\n\r\n        if( _s.mode == 'select' ){\r\n            tranDuration = 0;\r\n            this.input.set.call(this)\r\n        }\r\n\r\n        // if only a single tag is to be removed.\r\n        // skip \"select\" mode because invalid tags are actually set to `this.value`\r\n        if( tagsToRemove.length == 1 && _s.mode != 'select' ){\r\n            if( tagsToRemove[0].node.classList.contains(_s.classNames.tagNotAllowed) )\r\n                silent = true\r\n        }\r\n\r\n        if( !tagsToRemove.length )\r\n            return;\r\n\r\n        return _s.hooks.beforeRemoveTag(tagsToRemove, {tagify:this})\r\n            .then(() => {\r\n                function removeNode( tag ){\r\n                    if( !tag.node.parentNode ) return\r\n\r\n                    tag.node.parentNode.removeChild(tag.node)\r\n\r\n                    if( !silent ){\r\n                        // this.removeValueById(tagData.__uid)\r\n                        this.trigger('remove', { tag:tag.node, index:tag.idx, data:tag.data })\r\n                        this.dropdown.refilter()\r\n                        this.dropdown.position()\r\n                        this.DOM.input.normalize() // best-practice when in mix-mode (safe to do always anyways)\r\n\r\n                        // check if any of the current tags which might have been marked as \"duplicate\" should be un-marked\r\n                        if( _s.keepInvalidTags )\r\n                            this.reCheckInvalidTags()\r\n\r\n                        // below code is unfinished. it should iterate all currently invalid edited tags, which their edits have not\r\n                        // changed the value yet, and should re-trigger the check, but since nothing has changed, it does not work...\r\n                        // this.getTagElms(_s.classNames.tagEditing).forEach( this.events.callbacks.onEditTagBlur.bind )\r\n                    }\r\n                    else if( _s.keepInvalidTags )\r\n                        this.trigger('remove', { tag:tag.node, index:tag.idx })\r\n                }\r\n\r\n                function animation( tag ){\r\n                    tag.node.style.width = parseFloat(window.getComputedStyle(tag.node).width) + 'px'\r\n                    document.body.clientTop // force repaint for the width to take affect before the \"hide\" class below\r\n                    tag.node.classList.add(_s.classNames.tagHide)\r\n\r\n                    // manual timeout (hack, since transitionend cannot be used because of hover)\r\n                    setTimeout(removeNode.bind(this), tranDuration, tag)\r\n                }\r\n\r\n                if( tranDuration && tranDuration > 10 && tagsToRemove.length == 1 )\r\n                    animation.call(this, tagsToRemove[0])\r\n                else\r\n                    tagsToRemove.forEach(removeNode.bind(this))\r\n\r\n                // update state regardless of animation\r\n                if( !silent ){\r\n                    this.removeTagsFromValue(tagsToRemove.map(tag => tag.node))\r\n                    this.update() // update the original input with the current value\r\n\r\n                    if( _s.mode == 'select' && _s.userInput )\r\n                        this.setContentEditable(true);\r\n                }\r\n            })\r\n            .catch(reason => {})\r\n    },\r\n\r\n    removeTagsFromDOM(){\r\n        this.getTagElms().forEach(node => node.remove())\r\n    },\r\n\r\n    /**\r\n     * @param {Array/Node} tags to be removed from the this.value array\r\n     */\r\n    removeTagsFromValue( tags ){\r\n        tags = Array.isArray(tags) ? tags : [tags];\r\n\r\n        tags.forEach(tag => {\r\n            var tagData = getSetTagData(tag),\r\n                tagIdx = this.getTagIdx(tagData)\r\n\r\n            //  delete tagData.__removed\r\n\r\n            if( tagIdx > -1 )\r\n                this.value.splice(tagIdx, 1)\r\n        })\r\n    },\r\n\r\n    removeAllTags( opts ){\r\n        opts = opts || {}\r\n        this.value = []\r\n\r\n        if( this.settings.mode == 'mix' )\r\n            this.DOM.input.innerHTML = ''\r\n        else\r\n            this.removeTagsFromDOM()\r\n\r\n        this.dropdown.refilter()\r\n        this.dropdown.position()\r\n\r\n        if( this.state.dropdown.visible )\r\n            setTimeout(() => {\r\n                this.DOM.input.focus()\r\n            })\r\n\r\n        if( this.settings.mode == 'select' ){\r\n            this.input.set.call(this)\r\n            this.settings.userInput && this.setContentEditable(true)\r\n        }\r\n\r\n        // technically for now only \"withoutChangeEvent\" exists in the opts.\r\n        // if more properties will be added later, only pass what's needed to \"update\"\r\n        this.update(opts)\r\n    },\r\n\r\n    postUpdate(){\r\n        this.state.blockChangeEvent = false\r\n\r\n        var _s = this.settings,\r\n            classNames = _s.classNames,\r\n            hasValue = _s.mode == 'mix'\r\n                ? _s.mixMode.integrated\r\n                    ? this.DOM.input.textContent\r\n                    : this.DOM.originalInput.value.trim()\r\n                : this.value.length + this.input.raw.call(this).length;\r\n\r\n        this.toggleClass(classNames.hasMaxTags, this.value.length >= _s.maxTags)\r\n        this.toggleClass(classNames.hasNoTags, !this.value.length)\r\n        this.toggleClass(classNames.empty, !hasValue)\r\n\r\n        // specifically the \"select mode\" might have the \"invalid\" classname set when the field is changed, so it must be toggled on add/remove/edit\r\n        if( _s.mode == 'select' ){\r\n            this.toggleScopeValidation(this.value?.[0]?.__isValid)\r\n        }\r\n    },\r\n\r\n    setOriginalInputValue( v ){\r\n        var inputElm = this.DOM.originalInput;\r\n\r\n        if( !this.settings.mixMode.integrated ){\r\n            inputElm.value = v\r\n            inputElm.tagifyValue = inputElm.value // must set to \"inputElm.value\" and not again to \"inputValue\" because for some reason the browser changes the string afterwards a bit.\r\n            this.setPersistedData(v, 'value')\r\n        }\r\n    },\r\n\r\n    /**\r\n     * update the origianl (hidden) input field's value\r\n     * see - https://stackoverflow.com/q/50957841/104380\r\n     */\r\n    update( args ){\r\n        const UPDATE_DELAY = 100\r\n        clearTimeout(this.debouncedUpdateTimeout)\r\n        this.debouncedUpdateTimeout = setTimeout(reallyUpdate.bind(this), UPDATE_DELAY)\r\n        this.events.bindOriginaInputListener.call(this, UPDATE_DELAY)\r\n\r\n        function reallyUpdate() {\r\n            var inputValue = this.getInputValue();\r\n\r\n            this.setOriginalInputValue(inputValue)\r\n\r\n            if( (!this.settings.onChangeAfterBlur || !(args||{}).withoutChangeEvent) && !this.state.blockChangeEvent )\r\n                this.triggerChangeEvent()\r\n\r\n            this.postUpdate()\r\n        }\r\n    },\r\n\r\n    getInputValue(){\r\n        var value = this.getCleanValue();\r\n\r\n        return this.settings.mode == 'mix'\r\n            ? this.getMixedTagsAsString(value)\r\n            : value.length\r\n                ? this.settings.originalInputValueFormat\r\n                    ? this.settings.originalInputValueFormat(value)\r\n                    : JSON.stringify(value)\r\n                : \"\"\r\n    },\r\n\r\n    /**\r\n     * removes properties from `this.value` which are only used internally\r\n     */\r\n    getCleanValue(v){\r\n        return removeCollectionProp(v || this.value, this.dataProps);\r\n    },\r\n\r\n    getMixedTagsAsString(){\r\n        var result = \"\",\r\n            that = this,\r\n            _s = this.settings,\r\n            originalInputValueFormat = _s.originalInputValueFormat || JSON.stringify,\r\n            _interpolator = _s.mixTagsInterpolator;\r\n\r\n        function iterateChildren(rootNode){\r\n            rootNode.childNodes.forEach((node) => {\r\n                if( node.nodeType == 1 ){\r\n                    const tagData = getSetTagData(node);\r\n\r\n                    if( node.tagName == 'BR'  ){\r\n                        result += \"\\r\\n\";\r\n                    }\r\n\r\n                    if( tagData && isNodeTag.call(that, node) ){\r\n                        if( tagData.__removed )\r\n                            return;\r\n                        else\r\n                            result += _interpolator[0] + originalInputValueFormat( omit(tagData, that.dataProps) ) + _interpolator[1]\r\n                    }\r\n                    else if( node.getAttribute('style') || ['B', 'I', 'U'].includes(node.tagName)  )\r\n                        result += node.textContent;\r\n\r\n                    else if( node.tagName == 'DIV' || node.tagName == 'P' ){\r\n                        result += \"\\r\\n\";\r\n                        //  if( !node.children.length && node.textContent )\r\n                        //  result += node.textContent;\r\n                        iterateChildren(node)\r\n                    }\r\n                }\r\n                else\r\n                    result += node.textContent;\r\n            })\r\n        }\r\n\r\n        iterateChildren(this.DOM.input)\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n// legacy support for changed methods names\r\nTagify.prototype.removeTag = Tagify.prototype.removeTags\r\n\r\nexport default Tagify\r\n", "import { extend, logger } from './helpers'\r\n\r\nexport default function EventDispatcher( instance ){\r\n    // Create a DOM EventTarget object\r\n    var target = document.createTextNode(''),\r\n        // keep track of all binded events & their callbacks to be able to completely remove all listeners of a speicific type\r\n        callbacksPerType = {}\r\n\r\n    function addRemove(op, events, cb){\r\n        if( cb )\r\n            events.split(/\\s+/g).forEach(ev => target[op + 'EventListener'].call(target, ev, cb))\r\n    }\r\n\r\n    // Pass EventTarget interface calls to DOM EventTarget object\r\n    return {\r\n        // unbinds all events\r\n        removeAllCustomListeners(){\r\n            Object.entries(callbacksPerType).forEach(([ev, cbArr]) => {\r\n                cbArr.forEach(cb => addRemove('remove', ev, cb))\r\n            })\r\n\r\n            callbacksPerType = {}\r\n        },\r\n\r\n        off(events, cb){\r\n            if( events ) {\r\n                if( cb )\r\n                    addRemove('remove', events, cb)\r\n                else\r\n                    // if `cb` argument was not specified then remove all listeners for the given event(s) types\r\n                    events.split(/\\s+/g).forEach(ev => {\r\n                        callbacksPerType[ev]?.forEach(cb => addRemove('remove', ev, cb))\r\n                        delete callbacksPerType[ev]\r\n                    })\r\n            }\r\n\r\n            return this\r\n        },\r\n\r\n        on(events, cb){\r\n            if(cb && typeof cb == 'function') {\r\n                //track events callbacks to be able to remove them altogehter\r\n                events.split(/\\s+/g).forEach(ev => {\r\n                    if (Array.isArray(callbacksPerType[ev]) )\r\n                        callbacksPerType[ev].push(cb)\r\n                    else\r\n                        callbacksPerType[ev] = [cb]\r\n                })\r\n\r\n                addRemove('add', events, cb)\r\n            }\r\n\r\n            return this\r\n        },\r\n\r\n        trigger(eventName, data, opts){\r\n            var e;\r\n\r\n            opts = opts || {\r\n                cloneData:true\r\n            }\r\n\r\n            if( !eventName ) return;\r\n\r\n            if( instance.settings.isJQueryPlugin ){\r\n                if( eventName == 'remove' ) eventName = 'removeTag' // issue #222\r\n                jQuery(instance.DOM.originalInput).triggerHandler(eventName, [data])\r\n            }\r\n            else{\r\n                try {\r\n                    var eventData = typeof data === 'object'\r\n                        ? data\r\n                        : {value:data};\r\n\r\n                    eventData = opts.cloneData ? extend({}, eventData) : eventData\r\n                    eventData.tagify = this\r\n\r\n                    if( data.event )\r\n                        eventData.event = this.cloneEvent(data.event)\r\n\r\n                    // TODO: move the below to the \"extend\" function\r\n                    if( data instanceof Object )\r\n                        for( var prop in data )\r\n                            if(data[prop] instanceof HTMLElement)\r\n                                eventData[prop] = data[prop]\r\n\r\n                    e = new CustomEvent(eventName, {\"detail\":eventData})\r\n                }\r\n                catch(err){ logger.warn(err) }\r\n\r\n                target.dispatchEvent(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["ZERO_WIDTH_UNICODE_CHAR", "t", "e", "i", "n", "logger", "isEnabled", "window", "TAGIFY_DEBUG", "log", "_len", "arguments", "length", "args", "Array", "_key", "console", "this", "_to_consumable_array", "warn", "sameStr", "s1", "s2", "caseSensitive", "trim", "toLowerCase", "removeCollectionProp", "collection", "unwantedProps", "isArray", "map", "v", "omit", "obj", "props", "p", "newObj", "indexOf", "decode", "s", "el", "document", "createElement", "replace", "enc", "innerHTML", "innerText", "parseHTML", "DOMParser", "parseFromString", "body", "firstElementChild", "getfirstTextNode", "elm", "action", "nodeType", "escapeHTML", "isObject", "type", "Object", "prototype", "toString", "call", "split", "slice", "extend", "o", "o1", "o2", "copy", "a", "b", "key", "hasOwnProperty", "assign", "concatWithoutDups", "newArr", "existingObj", "_iteratorNormalCompletion", "_didIteratorError", "_iteratorError", "undefined", "_step", "_iterator", "Symbol", "iterator", "arr", "value", "_iteratorNormalCompletion1", "_didIteratorError1", "_iteratorError1", "_step1", "_iterator1", "item", "push", "includes", "err", "return", "unaccent", "String", "normalize", "isChromeAndroidBrowser", "test", "navigator", "userAgent", "getUID", "c", "crypto", "getRandomValues", "Uint8Array", "isNodeTag", "node", "classList", "contains", "settings", "classNames", "tag", "isWithinNodeTag", "closest", "tagSelector", "injectAtCaret", "content", "range", "selection", "getSelection", "getRangeAt", "createTextNode", "deleteContents", "insertNode", "getSetTagData", "tagElm", "data", "override", "__tagifyTagData", "placeCaretAfterNode", "parentNode", "nextSibling", "sel", "rangeCount", "setStartAfter", "collapse", "removeAllRanges", "addRange", "fixCaretBetweenTags", "tags", "TagifyHasFocuse", "forEach", "previousSibling", "textNode", "before", "DEFAULTS", "delimiters", "pattern", "tagTextProp", "maxTags", "Infinity", "callbacks", "addTagOnBlur", "addTagOn", "onChangeAfterBlur", "duplicates", "whitelist", "blacklist", "enforceWhitelist", "userInput", "focusable", "keepInvalidTags", "createInvalidTags", "mixTagsAllowedAfter", "mixTagsInterpolator", "backspace", "skipInvalid", "pasteAsTags", "editTags", "clicks", "keepInvalid", "transformTag", "a11y", "focusableTags", "mixMode", "insertAfterTag", "autoComplete", "enabled", "rightKey", "tabKey", "namespace", "selectMode", "input", "focus", "tagNoAnimation", "tagInvalid", "tagNotAllowed", "scopeLoading", "hasMaxTags", "hasNoTags", "empty", "inputInvalid", "dropdown", "dropdownWrapper", "dropdownHeader", "dropdownFooter", "dropdownItem", "dropdownItemActive", "dropdownItemHidden", "dropdownInital", "tagText", "tagX", "tagLoading", "tagEditing", "tagFlash", "tagHide", "classname", "maxItems", "searchKeys", "fuzzySearch", "accentedSearch", "includeSelectedTags", "highlightFirst", "closeOnSelect", "clearOnSelect", "position", "appendTarget", "hooks", "beforeRemoveTag", "Promise", "resolve", "beforePaste", "suggestionClick", "beforeKeyDown", "initDropdown", "_dropdown", "bind", "refs", "DOM", "__tagify", "deleteBackspaceTimeout", "_object_spread_props", "suggestionsMethods", "events", "binding", "bindUnbind", "_CB", "_CBR", "listeners", "onKeyDown", "onMouseOver", "onMouseLeave", "onClick", "onScroll", "state", "hasFocus", "composing", "_s", "selectedElm", "querySelector", "dropdownItemActiveSelector", "selectedElmData", "getSuggestionDataByNode", "isMixMode", "mode", "isSelectMode", "tagify", "then", "result", "preventDefault", "dropdownItems", "_this", "getAllSuggestionsRefs", "actionUp", "getNextOrPrevOption", "matches", "dropdownItemSelector", "highlightOption", "hide", "actions", "ArrowLeft", "shouldAutocompleteOnKey", "editing", "getMappedValue", "autocomplete", "set", "tagData", "suggestionElm", "selectOption", "addTags", "inputText", "catch", "scope", "raw", "charCodeAt", "removeTags", "setTimeout", "editTag", "ddItem", "target", "button", "pos", "scrollTop", "scrollHeight", "clientHeight", "trigger", "percentage", "Math", "round", "refilter", "query", "suggestedListItems", "filterListItems", "fill", "getAttribute", "find", "selected", "next", "selectedIdx", "findIndex", "adjustScroll", "itemData", "className", "ddItemElm", "remove", "removeAttribute", "ddItemData", "suggest", "add", "setAttribute", "offsetTop", "event", "isNoMatch", "normalizedTagData", "normalizeTags", "onEditTagDone", "__isValid", "toggleFocusClass", "addEventListener", "fillHeaderFooter", "once", "selectAll", "onlyRendered", "tagsToAdd", "suggestions", "options", "whitelistItem", "valueIsInWhitelist", "searchBy", "isDuplicate", "niddle", "l", "startsWithMatch", "exactMatch", "_searchKeys", "keys", "some", "k", "_sd", "exact", "reduce", "values", "every", "q", "isTagDuplicate", "exactMatchesList", "sortby", "list", "unshift", "d", "suggestionsCount", "filter", "_this1", "concat", "mapValueTo", "createListHTML", "sugegstionsList", "suggestion", "idx", "mappedValue", "templates", "apply", "join", "parseTemplate", "getHeaderRef", "getFooterRef", "querySelectorAll", "show", "firstListItem", "firstListItemValue", "noMatchListItem", "allowNewTags", "noWhitelist", "isManual", "dropdownItemNoMatch", "enable", "isLoading", "readonly", "clearTimeout", "dropdownHide__bindEventsTimeout", "visible", "setStateSelection", "render", "overrideManual", "_this_DOM", "removeEventListener", "removeChild", "flaggedTags", "baseOffset", "toggle", "getAppendTarget", "height", "clone", "ddHeight", "cloneNode", "style", "cssText", "appendChild", "HTMLContent", "dropdownContent", "newHeaderElem", "newFooterElem", "headerRef", "footerRef", "replaceChild", "rect", "top", "bottom", "left", "width", "ancestorsOffsets", "isPlacedAbove", "cssTop", "cssLeft", "ddElm", "isRTL", "RTL", "isDefaultAppendTarget", "isSelfAppended", "appendTargetScrollTop", "pageYOffset", "root", "fullscreenElement", "webkitFullscreenElement", "documentElement", "viewportHeight", "positionTo", "max", "clientWidth", "innerWidth", "ddTarget", "r2", "r", "startContainer", "offset", "startOffset", "createRange", "setStart", "setEnd", "getBoundingClientRect", "right", "getCaretGlobalPosition", "offsetLeft", "accumulatedAncestorsScrollTop", "floor", "ceil", "placeAbove", "pageXOffset", "STORE_KEY", "TEXTS", "exceed", "duplicate", "notAllowed", "wrapper", "disabled", "required", "placeholder", "param", "title", "class", "getAttributes", "_t", "hasMore", "customBinding", "customEventsList", "name", "on", "mainEvents", "eventName", "main", "bindGlobal", "isJQueryPlugin", "jQuery", "originalInput", "removeAllTags", "keydown", "onKeydown", "click", "onClickScope", "dblclick", "onDoubleClickScope", "paste", "onPaste", "drop", "onDrop", "compositionstart", "onCompositionStart", "compositionend", "onCompositionEnd", "inputMutationObserver", "MutationObserver", "onInputDOMChange", "disconnect", "observe", "childList", "bindOriginaInputListener", "delay", "DELAY", "clearInterval", "originalInputValueObserverInterval", "setInterval", "observeOriginalInputValue", "unbind", "global", "isIE", "cb", "onWindowKeyDown", "onFocusBlur", "onClickAnywhere", "useCapture", "unbindGlobal", "_this_value_", "_this_value", "nodeTag", "targetIsTagNode", "isFocused", "lostFocus", "tagTextSelector", "Date", "text", "textContent", "currentDisplayValue", "ddEnabled", "eventData", "relatedTarget", "isTargetSelectOption", "isTargetAddNewBtn", "addNew", "postUpdate", "dropdownCanBeShown", "loading", "firstTagNode", "getTagElms", "nextTag", "focusedElm", "activeElement", "isBelong", "isReadyOnlyTag", "hasAttribute", "nextElementSibling", "targetIsRemoveBtn", "deleteKeyTagDetected", "anchorOffset", "anchorNode", "prevAnchorSibling", "isCaretAfterTag", "lastTagElems", "tagBeforeCaret", "tagElmToBeDeleted", "firstTextNodeBeforeTag", "isZWS", "nodeValue", "fromCharCode", "previousElementSibling", "_instanceof", "Element", "nodeName", "min", "nodeIdx", "index", "isManualDropdown", "blur", "inputSuggestion", "onInput", "onMixTagsInput", "showSuggestions", "inputElm", "validation", "validateTag", "toggleScopeValidation", "isValid", "search", "rangeText", "match", "matchedPatternCount", "matchFlaggedTag", "matchDelimiters", "lastTagsCount", "tagsElems", "fragment", "createDocumentFragment", "remainingTagsValues", "inputType", "createTagElem", "childNodes", "setRangeAtStartEnd", "lastChild", "update", "withoutChangeEvent", "cloneRange", "focusNode", "endOffset", "lastIndexOf", "prefix", "onInputIE", "destroy", "tagifyValue", "loadOriginalValues", "isScope", "timeDiffFocus", "getNodeIndex", "fixFirefoxLastTagNoCaret", "clipboardData", "pastedText", "getData", "onEditTagInput", "editableElm", "_obj", "tagElmIdx", "textValue", "dataForChangedProp", "_define_property", "__tagId", "editTagChangeDetected", "originalIsValid", "newValue", "onEditTagPaste", "newNode", "onEditTagClick", "onEditTagFocus", "onEditTagBlur", "isRelatedTargetNodeTag", "newTagData", "originalData", "__originalData", "hasChanged", "_obj1", "message", "onEditTagkeydown", "__originalHTML", "EDITED_TAG_BLUR_DELAY", "isEditingTag", "editable", "m", "record", "addedNodes", "addedNode", "outerHTML", "replaceWith", "newlineText", "nextNode", "anythingAfterNode", "removedNodes", "removedNode", "lastInputChild", "Tagify", "mockInstance", "Proxy", "get", "id", "instance", "callbacksPerType", "addRemove", "op", "ev", "removeAllCustomListeners", "entries", "cbArr", "off", "opts", "cloneData", "triggerHandler", "cloneEvent", "prop", "HTMLElement", "CustomEvent", "detail", "dispatchEvent", "isFirefox", "documentMode", "getPersistedData", "persistedData", "customKey", "localStorage", "getItem", "JSON", "parse", "setPersistedData", "setItem", "stringify", "Event", "clearPersistedData", "base", "removeItem", "applySettings", "build", "getCSSVars", "autofocus", "helpers", "dataProps", "template", "setContentEditable", "generateClassSelectors", "currentName", "defineProperty", "mergedDefaults", "attrVal", "RegExp", "_delimiters", "_object_spread", "texts", "persistedWhitelist", "attrs", "getCustomAttributes", "propName", "output", "compStyle", "getComputedStyle", "CSSVars", "tagHideTransition", "unit", "pop", "getPropertyValue", "labelWrapper", "integrated", "originalInput_tabIndex", "tabIndex", "inputSelector", "insertBefore", "blockChangeEvent", "persistedOriginalValue", "parseMixTags", "tagName", "insertAdjacentHTML", "lastOriginalValueReported", "clonedEvent", "toggleClass", "force", "setPlaceholder", "str", "triggerChangeEvent", "changed", "bubbles", "simulated", "_valueTracker", "setValue", "random", "start", "getTagTextNode", "setTagTextNode", "HTML", "getLastTag", "tagIdx", "skipValidation", "editTagToggleValidity", "removeTagsFromValue", "previousData", "replaceTag", "reCheckInvalidTags", "getInvalidTagAttrs", "newTagElm", "updateValueByDOMTags", "injectedNode", "_this_state_selection", "appendMixTags", "updateDOM", "hideDropdown", "validate", "source", "charAt", "suggestedText", "suggestionStart", "substr", "suggestionTrimmed", "substring", "dataSuggest", "replaceTextWithNode", "getTagIdx", "classess", "_sc", "tagNodes", "tagId", "dupsCount", "done", "getTagIndexByValue", "indices", "isCaseSensitive", "getTagElmByValue", "flashTag", "isTagBlacklisted", "x", "isTagWhitelisted", "getWhitelistItem", "_wi", "_wiv", "setReadonly", "attrribute", "contentEditable", "setDisabled", "isDisabled", "tagsItems", "_this_settings", "whitelistMatches", "whitelistWithProps", "isCollection", "mapStringToCollection", "acc", "trimmed", "itemCopy", "whitelistMatchesValues", "filteredList", "filteredItem", "matchObj", "tagsDataSet", "textProp", "preInterpolated", "maxTagsReached", "Error", "newWrapperNode", "strToReplace", "nodeToReplace", "nodeAtCaret", "firstSplitOffset", "splitText", "prepareNewTagNode", "aggregatedInvalidInput", "tagElmParams", "__preInvalidData", "postProcessNewTagNode", "selectTag", "lastTagElm", "appendTag", "addEmptyTag", "initialData", "clearInput", "tagElems", "frag", "addMixTags", "newTagNode", "tagsData", "prefixedTextToTag", "children", "_this_state_tag", "newTag", "createdFromDelimiters", "insertBeforeNode", "extraData", "templateData", "textnode", "iter", "createNodeIterator", "NodeFilter", "SHOW_TEXT", "tagValidation", "tagElms", "silent", "tranDuration", "tagsToRemove", "elms", "__removed", "removeNode", "parseFloat", "clientTop", "reason", "removeTagsFromDOM", "splice", "hasValue", "setOriginalInputValue", "debouncedUpdateTimeout", "inputValue", "getInputValue", "getCleanValue", "getMixedTagsAsString", "originalInputValueFormat", "that", "_interpolator", "iterateChildren", "rootNode", "removeTag"]
}
